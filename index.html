<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Photo Heatmap Viewer - Simplified</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <!-- Add MarkerCluster if you want clustering -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="static/style.css" />    
</head>

<body>
    <div id="map"></div>
    <div class="controls-container">
        <div class="controls-toggle" id="controlsToggle" aria-controls="controlsPanel" aria-expanded="false">
            <span>Photo Heatmap</span>
            <span class="toggle-icon">▲</span>
        </div>
        <div class="controls" id="controlsPanel" style="display: none;">
            <div>
                <label for="intensity">Intensity: </label>
                <input type="range" id="intensity" min="1" max="30" value="15">
            </div>
            <div>
                <label for="radius">Radius: </label>
                <input type="range" id="radius" min="5" max="50" value="25">
            </div>
            <div>
                <input type="checkbox" id="showMarkers" checked>
                <label for="showMarkers">Show Photos Count</label>
            </div>
            <div class="library-filters">
                <h4>Libraries</h4>
                <div>
                    <input type="checkbox" id="selectAllLibraries" checked>
                    <label for="selectAllLibraries"><strong>All Libraries</strong></label>
                </div>
                <div id="libraryFilterContainer">
                    <!-- Library filters will be added here dynamically -->
                </div>
            </div>

            <div>
                <button id="updateMap">Update Map</button>
                <button id="fullscreenBtn" style="margin-left: 10px;">Fullscreen</button>
            </div>

            <div id="photoCount"></div>
        </div>
    </div>
    <div class="debug-panel-container">
        <div class="debug-panel-toggle" id="debugPanelToggle">
            <span>Debug Info</span>
            <span class="toggle-icon">▲</span>
        </div>
        <div class="debug-panel" id="debugPanel"></div>
    </div>
    <div class="loading" id="loading">
        <h2>Loading photo data...</h2>
        <p>Please wait while we load your photo data.</p>
        <button onclick="location.reload()">Retry</button>
    </div>

    <!-- Photo Viewer Dialog -->
    <div id="photoViewerOverlay" class="photo-viewer-overlay">
        <div class="photo-viewer-container">
            <div class="photo-viewer-header">
                <div class="photo-viewer-title">Photo Viewer</div>
                <button class="photo-viewer-close" id="closePhotoViewer">&times;</button>
            </div>
            <div class="photo-viewer-content">
                <div class="photo-viewer-image">
                    <img id="photoViewerImg" src="" alt="Photo">                    
                    <div class="image-controls">                         
                        <button class="image-control-btn" id="rotateLeftBtn" title="Rotate Left ([ or L key)">↺</button>
                        <button class="image-control-btn" id="rotateRightBtn" title="Rotate Right (] key)">↻</button>
                        <button class="image-control-btn" id="zoomInBtn" title="Zoom In (+ key)">+</button>
                        <button class="image-control-btn" id="zoomOutBtn" title="Zoom Out (- key)">-</button>
                        <button class="image-control-btn" id="resetViewBtn" title="Reset View (0 or R key)">R</button>
                    </div>
                </div>
                <div class="photo-viewer-info">
                    <div class="photo-viewer-detail">
                        <div class="photo-info-item">
                            <div class="photo-info-label">Filename:</div>
                            <div id="photoInfoFilename"></div>
                        </div>
                        <div class="photo-info-item">
                            <div class="photo-info-label">Date:</div>
                            <div id="photoInfoDate"></div>
                        </div>
                        <div class="photo-info-item">
                            <div class="photo-info-label">Location:</div>
                            <div id="photoInfoLocation"></div>
                        </div>                        
                    </div>
                </div>
            </div>
            <div class="photo-viewer-footer">
                <div class="photo-info-item">
                        <div class="photo-info-label">Path:</div>
                        <div id="photoInfoPath"></div>
                    </div>
                <div class="photo-viewer-nav">
                    <button id="prevPhotoBtn" class="photo-nav-btn">&lt; Previous</button>
                    <div class="photo-viewer-counter">
                        <span id="currentPhotoIndex">1</span> / <span id="totalPhotos">1</span>
                    </div>
                    <button id="nextPhotoBtn" class="photo-nav-btn">Next &gt;</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Add panel toggle functionality
        // Mobile detection is already done before map initialization
        
        document.addEventListener('DOMContentLoaded', function () {
            // Set mobile-specific body class
            if (isMobile) {
                document.body.classList.add('mobile-device');
            }
            
            // Debug panel toggle - only setup for desktop, on mobile it's hidden
            if (!isMobile) {
                const debugPanelToggle = document.getElementById('debugPanelToggle');
                if (debugPanelToggle) {
                    debugPanelToggle.addEventListener('click', function () {
                        const debugPanel = document.getElementById('debugPanel');
                        const toggleIcon = this.querySelector('.toggle-icon');

                        if (debugPanel.style.display === 'block') {
                            debugPanel.style.display = 'none';
                            toggleIcon.textContent = '▲';
                        } else {
                            debugPanel.style.display = 'block';
                            toggleIcon.textContent = '▼';
                        }
                    });
                }
            }
            
            // Controls panel toggle
            const controlsToggle = document.getElementById('controlsToggle');
            if (controlsToggle) {
                // Initialize the toggle text based on initial state
                const controlsPanel = document.getElementById('controlsPanel');
                const toggleIcon = controlsToggle.querySelector('.toggle-icon');
                
                // Always ensure toggle is visible
                controlsToggle.style.display = 'flex';
                
                // On mobile, start with panel hidden and update toggle icon
                if (isMobile) {
                    controlsPanel.style.display = 'none';
                    toggleIcon.textContent = '▲';
                    controlsToggle.setAttribute('aria-expanded', 'false');
                    controlsPanelVisible = false;
                }
                
                // Use touchend for mobile and click for desktop
                const toggleEvent = isMobile ? 'touchend' : 'click';
                controlsToggle.addEventListener(toggleEvent, function (e) {
                    if (isMobile) {
                        e.preventDefault();
                        e.stopPropagation(); // Prevent event bubbling
                    }
                    
                    if (controlsPanel.style.display === 'block') {
                        controlsPanel.style.display = 'none';
                        toggleIcon.textContent = '▲';
                        this.setAttribute('aria-expanded', 'false');
                        controlsPanelVisible = false;
                    } else {
                        controlsPanel.style.display = 'block';
                        toggleIcon.textContent = '▼';
                        this.setAttribute('aria-expanded', 'true');
                        controlsPanelVisible = true;
                    }
                });
            }
        });

        // Detect if we're on mobile (defined early so we can use it everywhere)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Track visibility states (helps with orientation changes)
        let controlsPanelVisible = false;
        
        // Immediately apply class to body for mobile-specific CSS
        if (isMobile) {
            document.body.classList.add('mobile-device');
            
            // Set controls container position immediately
            const controlsContainer = document.querySelector('.controls-container');
            if (controlsContainer) {
                controlsContainer.style.position = 'fixed';
                controlsContainer.style.bottom = '0';
                controlsContainer.style.top = 'auto';
                controlsContainer.style.left = '0';
                controlsContainer.style.right = '0';
                controlsContainer.style.width = '100%';
                controlsContainer.style.zIndex = '1001';
            }
        }
        
        // Debug logging function - defined based on device type
        let debugLog;
        if (isMobile) {
            // Simpler logging for mobile (console only)
            debugLog = function(message, data) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`, data || '');
            };
        } else {
            // Full logging with UI panel for desktop
            debugLog = function(message, data) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`, data || '');
                
                const panel = document.getElementById('debugPanel');
                if (panel) {
                    let dataText = '';
                    if (data) {
                        try {
                            dataText = typeof data === 'object' ?
                                `<pre>${JSON.stringify(data, null, 2)}</pre>` :
                                `<pre>${data}</pre>`;
                        } catch (e) {
                            dataText = '<pre>[Complex object]</pre>';
                        }
                    }
                    panel.innerHTML += `<div><strong>[${timestamp}]</strong> ${message} ${dataText}</div>`;
                    panel.scrollTop = panel.scrollHeight;
                }
            };
        }
        
        // Catch all errors
        window.addEventListener('error', function (e) {
            debugLog('ERROR: ' + e.message);
            return false;
        });
        
        // Hide debug panel and toggle on mobile devices
        if (isMobile) {
            const debugPanelContainer = document.querySelector('.debug-panel-container');
            if (debugPanelContainer) {
                debugPanelContainer.style.display = 'none';
            }
        }
        
        // Improve touch handling
        if (isMobile) {
            // Prevent touch events from interfering with map panning and zooming
            document.addEventListener('touchmove', function(e) {
                // Allow touch events inside controls and modals
                if (e.target.closest('.controls') || 
                    e.target.closest('.debug-panel') || 
                    e.target.closest('.photo-viewer-container')) {
                    return;
                }
                
                // Otherwise prevent default on map elements
                if (e.target.closest('#map')) {
                    if (e.touches.length === 1) { // Single touch = panning
                        // Let the map handle it
                    }
                }
            }, { passive: false });
        }
        
        // Handle device orientation changes and resizing
        function handleViewportChange() {
            // Add a small delay to allow the browser to complete the orientation change
            setTimeout(function() {
                map.invalidateSize();
                
                // Make sure our toggle is still visible after orientation change
                const controlsToggle = document.getElementById('controlsToggle');
                if (controlsToggle) {
                    controlsToggle.style.display = 'flex'; // Ensure toggle is visible
                }
                
                // Update the controls panel display based on our tracking variable
                const controlsPanel = document.getElementById('controlsPanel');
                if (controlsPanel) {
                    controlsPanel.style.display = controlsPanelVisible ? 'block' : 'none';
                }
                
                // Ensure controls container is at the bottom in mobile view
                if (isMobile) {
                    const controlsContainer = document.querySelector('.controls-container');
                    if (controlsContainer) {
                        controlsContainer.style.bottom = '0';
                        controlsContainer.style.top = 'auto';
                    }
                }
                
                debugLog('Viewport changed, map and controls updated');
            }, 300);
        }
        
        // Listen for both orientation and resize changes
        window.addEventListener('orientationchange', handleViewportChange);
        window.addEventListener('resize', handleViewportChange);
        
        // Initialize map
        debugLog('Initializing map');
        if (isMobile) {
            debugLog('Mobile device detected, optimizing layout');
            document.body.classList.add('mobile-device');
        }
        debugLog('Mobile device detected: ' + isMobile);
        
        const map = L.map('map', {
            minZoom: 2,
            maxZoom: 19,
            maxBounds: [
                [-90, -180],  // Southwest corner
                [90, 180]     // Northeast corner
            ],
            maxBoundsViscosity: 1.0,  // Strict bounds enforcement
            tap: isMobile, // Enable tap for mobile devices
            dragging: !isMobile || !L.Browser.mobile, // Disable drag on mobile by default
            tap: true, // Enable tap handler
            tapTolerance: 15 // Increased tap tolerance for mobile
        }).setView([50, 0], isMobile ? 3 : 5); // Adjust initial zoom for mobile


        // Update your tile layer to prevent wrapping:
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            noWrap: true,  // Prevent map from wrapping
            maxZoom: 19
        }).addTo(map);

        // Global variables
        let photoData = [];
        let filteredData = [];
        let heatLayer = null;
        let markerGroup = null;

        // Photo viewer variables
        let currentClusterPhotos = [];
        let currentPhotoIdx = 0;

        // DOM elements
        const intensitySlider = document.getElementById('intensity');
        const radiusSlider = document.getElementById('radius');
        const showMarkersCheckbox = document.getElementById('showMarkers');
        const updateMapButton = document.getElementById('updateMap');
        const photoCountElement = document.getElementById('photoCount');
        const loadingElement = document.getElementById('loading');
        // Photo viewer DOM elements
        const photoViewerOverlay = document.getElementById('photoViewerOverlay');
        const photoViewerImg = document.getElementById('photoViewerImg');
        const photoInfoFilename = document.getElementById('photoInfoFilename');
        const photoInfoDate = document.getElementById('photoInfoDate');
        const photoInfoLocation = document.getElementById('photoInfoLocation');
        const photoInfoPath = document.getElementById('photoInfoPath');
        const currentPhotoIndex = document.getElementById('currentPhotoIndex');
        const totalPhotos = document.getElementById('totalPhotos');
        const prevPhotoBtn = document.getElementById('prevPhotoBtn');
        const nextPhotoBtn = document.getElementById('nextPhotoBtn');
        const closePhotoViewerBtn = document.getElementById('closePhotoViewer');

        // Image control buttons
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn'); const resetViewBtn = document.getElementById('resetViewBtn');
        // Image transformations
        let currentZoom = 1;
        let currentRotation = 0;

        // Load photo data
        function loadPhotoData() {
            debugLog('Loading photo data');

            // Show loading indicator with progress bar
            loadingElement.style.display = 'flex';
            loadingElement.innerHTML = `
                <h2>Loading Photo Data</h2>
                <p>Please wait...</p>
                <div class="progress-bar" id="loadingProgress">
                    <div id="progressBar" style="width: 0%; height: 20px; background-color: #4CAF50; transition: width 0.3s;"></div>
                </div>
            `;
            // Use the new API endpoint for markers
            fetch('/api/markers')
                .then(response => {
                    debugLog(`Response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.text().then(text => {
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            debugLog(`JSON parse error: ${e.message}`);
                            debugLog(`JSON content (first 200 chars): ${text.substring(0, 200)}`);
                            throw new Error(`JSON parse error: ${e.message}`);
                        }
                    });
                }).then(data => {
                    // Handle both new and legacy JSON formats
                    let photos = [];
                    let libraries = [];

                    if (Array.isArray(data)) {
                        // Legacy format (just an array of photos)
                        photos = data;
                        debugLog(`Loaded ${photos.length} photos (legacy format)`);
                    } else {
                        // New format with photos and libraries
                        photos = data.photos || [];
                        libraries = data.libraries || [];
                        debugLog(`Loaded ${photos.length} photos from ${libraries.length} libraries`);

                        // Log libraries if available
                        if (libraries.length > 0) {
                            debugLog(`Available libraries: ${libraries.map(lib => lib.name).join(', ')}`);
                        }
                    }

                    // Store data globally
                    photoData = {
                        photos: photos,
                        libraries: libraries,
                        activeLibraries: libraries.map(lib => lib.id) // Start with all libraries active
                    };

                    // Create library filter controls
                    createLibraryFilters(libraries);

                    // Count photos with GPS coords
                    const withGPS = photos.filter(photo =>
                        photo.latitude != null && photo.longitude != null);
                    debugLog(`Photos with GPS: ${withGPS.length}/${photos.length}`);

                    // Update photo count display
                    photoCountElement.textContent = `${withGPS.length} photos with location`;

                    // Progressive loading sequence
                    const steps = [
                        {
                            name: 'Creating Heatmap',
                            action: () => {
                                updateHeatmap(withGPS);
                                if (withGPS.length > 0) {
                                    const bounds = L.latLngBounds(withGPS.map(photo => [photo.latitude, photo.longitude]));
                                    map.fitBounds(bounds);
                                }
                                document.getElementById('progressBar').style.width = '50%';
                            }
                        },
                        {
                            name: 'Preparing Markers',
                            action: () => {
                                if (showMarkersCheckbox.checked) {
                                    updateMarkers(withGPS);
                                }
                                document.getElementById('progressBar').style.width = '100%';
                            }
                        }
                    ];

                    // Execute steps in sequence
                    let currentStep = 0;
                    function executeNextStep() {
                        if (currentStep < steps.length) {
                            const step = steps[currentStep];
                            loadingElement.innerHTML = `
                                <h2>${step.name}</h2>
                                <p>Processing...</p>
                                <div class="progress-bar" style="width: 300px; height: 20px; background-color: #eee;">
                                    <div id="progressBar" style="width: ${currentStep * 50}%; height: 20px; background-color: #4CAF50; transition: width 0.3s;"></div>
                                </div>
                            `;

                            // Execute step with small delay to allow UI update
                            setTimeout(() => {
                                step.action();
                                currentStep++;
                                executeNextStep();
                            }, 10);
                        } else {
                            // All steps complete
                            loadingElement.style.display = 'none';
                        }
                    }

                    executeNextStep();
                })
                .catch(error => {
                    debugLog(`Error loading photo data: ${error.message}`);
                    loadingElement.innerHTML = `
                        <h2>Error Loading Data</h2>
                        <p>${error.message}</p>
                        <button onclick="location.reload()">Retry</button>
                    `;
                });
        }

        // Update map visualization with progressive loading        
        function updateVisualization() {
            debugLog('Updating visualization');

            const loadingStatus = document.createElement('div');
            loadingStatus.className = 'loading-status';
            loadingStatus.style.cssText = `
                position: absolute;
                bottom: 10px;
                right: 10px;
                background-color: rgba(255,255,255,0.9);
                padding: 10px;
                border-radius: 4px;
                z-index: 1000;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            document.body.appendChild(loadingStatus);

            try {
                // Use the filterAndUpdateMap function which handles active libraries
                filterAndUpdateMap();
            } catch (err) {
                debugLog('Error updating visualization: ' + err.message);
            } finally {
                // Remove loading status
                if (loadingStatus.parentNode) {
                    setTimeout(() => {
                        document.body.removeChild(loadingStatus);
                    }, 500); // Give some time to see the status
                }
            }
        }

        // Update heatmap
        function updateHeatmap(photos) {
            debugLog('Updating heatmap');

            // Remove existing heatmap if present
            if (heatLayer) {
                map.removeLayer(heatLayer);
            }

            // Create heatmap points
            const points = photos.map(photo => [
                photo.latitude,
                photo.longitude,
                1  // Weight
            ]);

            // Create new heatmap layer
            heatLayer = L.heatLayer(points, {
                radius: parseInt(radiusSlider.value),
                blur: 15,
                maxZoom: 10,
                gradient: { 0.4: 'blue', 0.65: 'lime', 1: 'red' },
                intensity: parseInt(intensitySlider.value) / 10
            }).addTo(map);

            debugLog(`Heatmap created with ${points.length} points`);
        }        // Update markers
        function updateMarkers(inputPhotos = []) {
    debugLog('Updating markers');

    // Deduplicate photos
    const photoMap = new Map();
    inputPhotos.forEach(photo => {
        const photoKey = photo.id || `${photo.latitude}_${photo.longitude}_${photo.filename}`;
        if (!photoMap.has(photoKey)) {
            photoMap.set(photoKey, photo);
        }
    });
    const uniquePhotos = Array.from(photoMap.values());
    const dupesRemoved = inputPhotos.length - uniquePhotos.length;

    if (dupesRemoved > 0) {
        debugLog(`Removed ${dupesRemoved} duplicate photos before creating markers`);
    }

    const filteredPhotos = uniquePhotos;
    debugLog(`Loading markers for ${filteredPhotos.length} unique photos...`);

    // Show loading indicator
    const markerLoadingStatus = document.createElement('div');
    markerLoadingStatus.className = 'marker-loading-status';
    markerLoadingStatus.innerHTML = '<strong>Loading markers...</strong>';
    Object.assign(markerLoadingStatus.style, {
        position: 'absolute',
        bottom: '10px',
        right: '10px',
        backgroundColor: 'rgba(255,255,255,0.8)',
        padding: '5px 10px',
        borderRadius: '4px',
        zIndex: '1000'
    });
    document.body.appendChild(markerLoadingStatus);

    // Remove old markers
    if (typeof markerGroup !== 'undefined' && markerGroup) {
        map.removeLayer(markerGroup);
    }

    // Create new marker group
    try {
        markerGroup = typeof L.markerClusterGroup === 'function'
            ? L.markerClusterGroup()
            : L.layerGroup();

        if (markerGroup.on) {
            markerGroup.on('clusterclick', function (e) {
                try {
                    const photos = e.layer.getAllChildMarkers()
                        .filter(marker => marker.photoData)
                        .map(marker => marker.photoData);

                    if (photos.length > 0) {
                        openPhotoViewer(photos, 0);
                    }
                } catch (err) {
                    debugLog('Error in cluster click handler: ' + err.message);
                }
            });
        }
    } catch (err) {
        debugLog('Error creating marker group: ' + err.message);
        markerGroup = L.layerGroup();
    }

    // Process markers (chunked if large dataset)
    const chunkSize = 100;
    let currentChunk = 0;
    const totalChunks = Math.ceil(filteredPhotos.length / chunkSize);

    function processChunk() {
        const start = currentChunk * chunkSize;
        const end = Math.min(start + chunkSize, filteredPhotos.length);

        for (let i = start; i < end; i++) {
            addMarker(filteredPhotos[i]);
        }

        markerLoadingStatus.innerHTML = `<strong>Loading markers: ${Math.min(100, Math.round((end / filteredPhotos.length) * 100))}%</strong>`;

        currentChunk++;
        if (currentChunk < totalChunks) {
            setTimeout(processChunk, 20);
        } else {
            finishMarkerLoading();
        }
    }

    if (filteredPhotos.length > 500) {
        debugLog(`Using chunked processing for ${filteredPhotos.length} markers`);
        processChunk();
    } else {
        filteredPhotos.forEach(photo => addMarker(photo));
        finishMarkerLoading();
    }

    function addMarker(photo) {
        if (photo.latitude == null || photo.longitude == null) {
            debugLog(`Skipping photo with invalid coordinates: ${photo.filename}`);
            return;
        }

        const marker = L.marker([photo.latitude, photo.longitude]);
        marker.photoData = photo;

        const container = document.createElement('div');
        container.className = 'marker-popup';
        container.innerHTML = `
            <strong>${photo.filename || 'Unknown'}</strong><br>
            ${photo.datetime ? new Date(photo.datetime).toLocaleString() : 'No date'}<br>
            <div class="popup-image-container" style="width: 150px; height: 150px; background: #f0f0f0; display: flex; align-items: center; justify-content: center;">
                <span class="loading-placeholder">Loading...</span>
            </div>
        `;

        marker.bindPopup(container);

        marker.on('popupopen', function () {
            const imageContainer = container.querySelector('.popup-image-container');
            if (!imageContainer.querySelector('img')) {
                const img = new Image();
                img.style.maxWidth = '150px';
                img.style.maxHeight = '150px';

                img.onload = function () {
                    imageContainer.innerHTML = '';
                    imageContainer.appendChild(img);
                };

                img.onerror = function () {
                    imageContainer.innerHTML = 'Image not available';
                    debugLog(`Failed to load popup image for ${photo.filename}`);
                };

                img.src = `photos/${encodeURIComponent(photo.filename)}`;
            }
        });

        marker.on('click', function (e) {
            let photosAtSameLocation = filteredPhotos.filter(p =>
                p.latitude === photo.latitude && p.longitude === photo.longitude
            );

            const locationMap = new Map();
            photosAtSameLocation.forEach(p => {
                const key = p.id || p.filename;
                if (!locationMap.has(key)) {
                    locationMap.set(key, p);
                }
            });
            photosAtSameLocation = Array.from(locationMap.values());

            debugLog(`Marker clicked: ${photo.filename} (${photosAtSameLocation.length} unique photos at this location)`);

            const index = photosAtSameLocation.findIndex(p =>
                p.id === photo.id || p.filename === photo.filename
            );

            openPhotoViewer(photosAtSameLocation, index >= 0 ? index : 0);
            e.originalEvent?.stopPropagation();
            L.DomEvent.stopPropagation(e);
        });

        markerGroup.addLayer(marker);
    }

    function finishMarkerLoading() {
        map.addLayer(markerGroup);
        markerLoadingStatus.remove();
        debugLog('Successfully added markers to map');
    }
}


        // Photo viewer functions
        function openPhotoViewer(photos, startIndex = 0) {
            if (!photos || photos.length === 0) {
                debugLog('Cannot open photo viewer: No photos provided');
                return;
            }

            debugLog(`Opening photo viewer with ${photos.length} photos, starting at index ${startIndex}`);

            // Handle large clusters more efficiently
            if (photos.length > 100) {
                debugLog(`Large cluster detected (${photos.length} photos). Using optimized handling.`);

                // Only store the first 100 photos for immediate viewing
                // Additional photos will be loaded on demand if user navigates that far
                currentClusterPhotos = [...photos.slice(0, 100)];

                // Store reference to full dataset for paged loading
                currentClusterPhotos.fullDataset = photos;
                currentClusterPhotos.loadedCount = 100;
            } else {
                // For smaller clusters, load all at once
                currentClusterPhotos = [...photos];
            }

            currentPhotoIdx = Math.min(startIndex, currentClusterPhotos.length - 1);
            totalPhotos.textContent = photos.length; // Show total including not-yet-loaded

            updatePhotoViewerContent();
            photoViewerOverlay.style.display = 'flex';
        }
        function closePhotoViewer() {
            debugLog('Closing photo viewer');
            photoViewerOverlay.style.display = 'none';
        }
        
        // Add swipe gesture support for mobile
        if (isMobile) {
            const photoContainer = document.querySelector('.photo-viewer-container');
            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0; 
            let touchEndY = 0;
            
            photoContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });
            
            photoContainer.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                
                // Calculate horizontal and vertical distances
                const horizontalDistance = touchEndX - touchStartX;
                const verticalDistance = Math.abs(touchEndY - touchStartY);
                
                // Only register as swipe if horizontal movement is significant and vertical movement is minimal
                if (Math.abs(horizontalDistance) > 100 && verticalDistance < 50) {
                    if (horizontalDistance > 0) {
                        // Swipe right - show previous photo
                        showPreviousPhoto();
                    } else {
                        // Swipe left - show next photo
                        showNextPhoto();
                    }
                }
            });
        }

        // Constants for virtual scrolling
        const PRELOAD_BATCH_SIZE = 50;
        const MAX_LOADED_PHOTOS = 200;

        function updatePhotoViewerContent() {
            const photo = currentClusterPhotos[currentPhotoIdx];
            if (!photo) {
                debugLog('Cannot update photo viewer: No photo at current index');
                return;
            }

            // Virtual scrolling: Manage loaded photos based on current index
            if (currentClusterPhotos.fullDataset) {
                const totalPhotos = currentClusterPhotos.fullDataset.length;
                const currentLoadedCount = currentClusterPhotos.length;

                // Calculate the window of photos we want to keep loaded
                const windowStart = Math.max(0, currentPhotoIdx - Math.floor(MAX_LOADED_PHOTOS / 2));
                const windowEnd = Math.min(totalPhotos, windowStart + MAX_LOADED_PHOTOS);

                // Load more photos if we're approaching the end of our loaded set
                if (currentPhotoIdx > currentLoadedCount - PRELOAD_BATCH_SIZE &&
                    currentLoadedCount < totalPhotos) {

                    const nextBatchSize = Math.min(PRELOAD_BATCH_SIZE,
                        totalPhotos - currentLoadedCount);

                    debugLog(`Loading next batch of ${nextBatchSize} photos (${currentLoadedCount + 1}-${currentLoadedCount + nextBatchSize} of ${totalPhotos})`);

                    const nextBatch = currentClusterPhotos.fullDataset.slice(
                        currentLoadedCount,
                        currentLoadedCount + nextBatchSize
                    );

                    currentClusterPhotos.push(...nextBatch);
                    currentClusterPhotos.loadedCount = currentClusterPhotos.length;
                }

                // Remove photos that are far from current index to manage memory
                if (currentClusterPhotos.length > MAX_LOADED_PHOTOS) {
                    const photosToRemove = [];

                    // Remove photos before the window
                    if (windowStart > 0) {
                        photosToRemove.push(...currentClusterPhotos.slice(0, windowStart));
                    }

                    // Remove photos after the window
                    if (windowEnd < currentClusterPhotos.length) {
                        photosToRemove.push(...currentClusterPhotos.slice(windowEnd));
                    }

                    if (photosToRemove.length > 0) {
                        debugLog(`Removing ${photosToRemove.length} photos outside viewing window`);
                        currentClusterPhotos = currentClusterPhotos.filter(p => !photosToRemove.includes(p));
                    }
                }
            }

            debugLog(`Updating photo viewer content to photo ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

            // Update navigation buttons state
            prevPhotoBtn.disabled = currentPhotoIdx <= 0;
            nextPhotoBtn.disabled = currentPhotoIdx >= currentClusterPhotos.length - 1;

            // Update counter
            currentPhotoIndex.textContent = currentPhotoIdx + 1;

            // Reset view when showing a new photo
            currentZoom = 1;
            currentRotation = 0;
            updateImageTransform();
            debugLog(`Loading image for ${photo.filename}`);
            // Set new image with error handling - using direct loading from photos endpoint
            // Use full images directly for better quality and reliability
            const fullImageUrl = `photos/${encodeURIComponent(photo.filename)}`;
            debugLog(`Loading full image URL: ${fullImageUrl}`);

            // Create new image to preload            // Create new image to preload without affecting current display
            const fullImg = new Image();
            fullImg.onload = function () {
                // Only change the src once the new image is fully loaded
                photoViewerImg.src = fullImageUrl;
                photoViewerImg.style.opacity = '1';
                debugLog(`Full image loaded: ${photo.filename}`);
            };

            // Handle image loading errors with better fallback
            fullImg.onerror = function () {
                debugLog(`Failed to load image for ${photo.filename}, trying alternative fallback`);
                // Try an alternative path if available in photo object
                if (photo.path) {
                    const alternativePath = `photos/${encodeURIComponent(photo.path)}`;
                    debugLog(`Trying alternative path: ${alternativePath}`);
                    photoViewerImg.src = alternativePath;
                } else {
                    // If all fails, show placeholder after a brief delay
                    setTimeout(() => {
                        photoViewerImg.src = 'https://placehold.co/800x600?text=Photo+Unavailable';
                        photoViewerImg.style.opacity = '1';
                    }, 500);
                }
            };

            fullImg.src = fullImageUrl;

            // Add error handler for the main viewer image as fallback
            photoViewerImg.onerror = () => {
                debugLog(`Failed to load image for ${photo.filename}, using placeholder`);
                photoViewerImg.src = 'https://placehold.co/800x600?text=Photo+Unavailable';
                photoViewerImg.style.opacity = '1';
            };
            // Handle successful load
            photoViewerImg.onload = function () {
                debugLog(`Successfully loaded image for ${photo.filename}, dimensions: ${this.naturalWidth}x${this.naturalHeight}`);

                // Make sure the image is visible
                this.style.opacity = '1';

                // Reset any previous sizing
                this.style.maxWidth = '';
                this.style.maxHeight = '';
                this.style.width = '';
                this.style.height = '';

                // Calculate aspect ratio
                const aspectRatio = this.naturalWidth / this.naturalHeight;
                const isPortrait = aspectRatio < 1;

                // Set appropriate dimensions based on orientation
                if (isPortrait) {
                    this.style.maxHeight = '85vh';
                    this.style.width = 'auto';
                } else {
                    this.style.maxWidth = '85vw';
                    this.style.height = 'auto';
                }

                debugLog(`Image orientation: ${isPortrait ? 'portrait' : 'landscape'}, aspect ratio: ${aspectRatio.toFixed(2)}`);

                // Apply any existing transformations
                updateImageTransform();
            };


            photoInfoFilename.textContent = photo.filename || 'Unknown';
            photoInfoDate.textContent = photo.datetime ? new Date(photo.datetime).toLocaleString() : 'Unknown';
            photoInfoLocation.textContent = (photo.latitude != null && photo.longitude != null) ?
                `${photo.latitude.toFixed(6)}, ${photo.longitude.toFixed(6)}` : 'Not available';
            photoInfoPath.textContent = photo.path || 'Unknown';
        }
        function showNextPhoto() {
            // Check if we need to load more photos
            if (currentPhotoIdx === currentClusterPhotos.length - 1 &&
                currentClusterPhotos.fullDataset &&
                currentClusterPhotos.loadedCount < currentClusterPhotos.fullDataset.length) {

                // Load next batch of photos
                const nextBatchSize = Math.min(50, currentClusterPhotos.fullDataset.length - currentClusterPhotos.loadedCount);
                debugLog(`Loading next batch of ${nextBatchSize} photos`);

                // Get the next batch
                const nextBatch = currentClusterPhotos.fullDataset.slice(
                    currentClusterPhotos.loadedCount,
                    currentClusterPhotos.loadedCount + nextBatchSize
                );

                // Add to the current set
                currentClusterPhotos.push(...nextBatch);
                currentClusterPhotos.loadedCount += nextBatchSize;

                debugLog(`Now loaded ${currentClusterPhotos.loadedCount} of ${currentClusterPhotos.fullDataset.length} photos`);
            }
            if (currentPhotoIdx < currentClusterPhotos.length - 1) {
                currentPhotoIdx++;
                debugLog(`Moving to next photo: ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

                // Preserve the current image opacity while we load the next one
                photoViewerImg.style.opacity = '0.8';
                updatePhotoViewerContent();
            }
        }
        function showPreviousPhoto() {
            if (currentPhotoIdx > 0) {
                currentPhotoIdx--;
                debugLog(`Moving to previous photo: ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

                // Preserve the current image opacity while we load the previous one
                photoViewerImg.style.opacity = '0.8';
                updatePhotoViewerContent();
            }
        }        // Event listeners
        updateMapButton.addEventListener('click', updateVisualization);

        showMarkersCheckbox.addEventListener('change', function () {
            debugLog(`Show markers changed: ${this.checked}`);
            updateVisualization();
        });
        // Photo viewer event listeners
        // Use the appropriate event (touchend for mobile, click for desktop)
        const eventType = isMobile ? 'touchend' : 'click';
        
        closePhotoViewerBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            closePhotoViewer();
        });
        
        prevPhotoBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            showPreviousPhoto();
        });
        
        nextPhotoBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            showNextPhoto();
        });
        
        // Image control event listeners
        rotateLeftBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            rotateLeft();
        });
        
        rotateRightBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            rotateRight();
        });
        // Note: zoomIn, zoomOut and resetView are handled by the existing event listeners
        // through the setZoomLevel function
        // Keyboard navigation in photo viewer
        document.addEventListener('keydown', function (e) {
            if (photoViewerOverlay.style.display === 'flex') {
                if (e.key === 'Escape') {
                    closePhotoViewer();
                } else if (e.key === 'ArrowRight') {
                    showNextPhoto();
                } else if (e.key === 'ArrowLeft') {
                    showPreviousPhoto();
                } else if (e.key === '+' || e.key === '=') {
                    // + or = key for zooming in (= is easier to press without shift)
                    zoomIn();
                } else if (e.key === '-') {
                    // - key for zooming out
                    zoomOut();
                } else if (e.key === '0' || e.key === 'r' || e.key === 'R') {
                    // 0 or r key for reset
                    resetView();
                } else if (e.key === '[' || e.key === 'l' || e.key === 'L') {
                    // [ or l key for rotate left
                    rotateLeft();
                } else if (e.key === ']') {
                    // ] key for rotate right
                    rotateRight();
                }
            }
        });
        // Load data when page is loaded
        window.addEventListener('load', function () {
            debugLog('Page loaded, fetching photo data...');
            loadPhotoData();

            // Set up debug cluster handlers after a short delay
            setTimeout(function () {
                debugClusterFunction();
                debugLog('Debug cluster setup complete');
            }, 2000);

            // Add a document-level click handler for clusters as a fallback
            document.addEventListener('click', function (e) {
                // Check if the click event target is a cluster
                let target = e.target;
                while (target && !target.classList.contains('marker-cluster') && target !== document.body) {
                    target = target.parentNode;
                }

                // If we found a cluster element
                if (target && target.classList.contains('marker-cluster')) {
                    debugLog('DOCUMENT LEVEL CLUSTER CLICK DETECTED');                    // This is a fallback - try to force the modal to open with all photos
                    if (photoData && photoData.photos && photoData.photos.length > 0) {
                        // Get valid photos with GPS data
                        const validPhotos = photoData.photos.filter(p => p.latitude && p.longitude).slice(0, 50);
                        
                        // Deduplicate photos
                        const photoMap = new Map();
                        validPhotos.forEach(p => {
                            const key = p.id || p.filename;
                            if (!photoMap.has(key)) {
                                photoMap.set(key, p);
                            }
                        });
                        
                        const uniquePhotos = Array.from(photoMap.values());
                        if (uniquePhotos.length > 0) {
                            debugLog(`Fallback opening viewer with ${uniquePhotos.length} photos`);
                            openPhotoViewer(uniquePhotos, 0);
                        }
                    }
                }
            });
        });
        // Zoom control functions
        function setZoomLevel(level) {
            currentZoom = level;
            // Use updateImageTransform to ensure consistency with rotation
            updateImageTransform();
            debugLog(`Zoom level set to ${currentZoom}`);
        }

        zoomInBtn.addEventListener(eventType, (e) => {
            if (isMobile) e.preventDefault();
            setZoomLevel(Math.min(currentZoom + 0.25, 4));
        });

        zoomOutBtn.addEventListener(eventType, (e) => {
            if (isMobile) e.preventDefault();
            setZoomLevel(Math.max(currentZoom - 0.25, 0.5));
        });
        
        resetViewBtn.addEventListener(eventType, (e) => {
            if (isMobile) e.preventDefault();
            setZoomLevel(1);
        });
        
        // Add pinch-zoom gesture support for mobile
        if (isMobile) {
            const photoImage = document.getElementById('photoViewerImg');
            let initialPinchDistance = 0;
            
            photoImage.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });
            
            photoImage.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault(); // Prevent default to allow pinch zoom
                    
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    if (initialPinchDistance > 0) {
                        const pinchRatio = currentDistance / initialPinchDistance;
                        const zoomDelta = pinchRatio > 1 ? 0.05 : -0.05;
                        const newZoom = Math.max(0.5, Math.min(4, currentZoom + zoomDelta));
                        setZoomLevel(newZoom);
                        initialPinchDistance = currentDistance;
                    }
                }
            }, { passive: false });
        }          // Image transformation functions
        function zoomIn() {
            // Use setZoomLevel to ensure consistency
            setZoomLevel(Math.min(currentZoom + 0.25, 4));
            debugLog(`Zoomed in to ${currentZoom}x`);
        }

        function zoomOut() {
            // Use setZoomLevel to ensure consistency
            setZoomLevel(Math.max(currentZoom - 0.25, 0.5));
            debugLog(`Zoomed out to ${currentZoom}x`);
        }

        function rotateLeft() {
            // Normalize rotation to keep it in the range of -360 to 360 degrees
            currentRotation = (currentRotation - 90) % 360;
            updateImageTransform();
            debugLog(`Rotated left to ${currentRotation} degrees`);
        }

        function rotateRight() {
            // Normalize rotation to keep it in the range of -360 to 360 degrees
            currentRotation = (currentRotation + 90) % 360;
            updateImageTransform();
            debugLog(`Rotated right to ${currentRotation} degrees`);
        }

        function resetView() {
            // Reset both zoom and rotation
            currentZoom = 1;
            currentRotation = 0;
            updateImageTransform();
            debugLog(`Reset view to default`);
        }
        function updateImageTransform() {
            // Apply transform with proper origin point
            const transform = `scale(${currentZoom}) rotate(${currentRotation}deg)`;
            photoViewerImg.style.transform = transform;
            photoViewerImg.style.transformOrigin = 'center center';

            debugLog(`Applied transform: ${transform}`);
        }

        // For debugging cluster clicks - override cluster click handling
        function debugClusterFunction() {
            debugLog('Setting up debug cluster click handling');
            if (markerGroup && typeof markerGroup.on === 'function') {
                debugLog('Adding direct cluster click handler');

                // Remove any existing handlers
                markerGroup.off('clusterclick');
                // Add our direct handler
                markerGroup.on('clusterclick', function (e) {
                    debugLog('DIRECT CLUSTER CLICK DETECTED!');

                    try {
                        const cluster = e.layer;
                        const count = cluster.getChildCount();
                        const markers = cluster.getAllChildMarkers();

                        debugLog(`Cluster has ${count} markers`);                        // Get photos from markers - with deduplication by ID
                        const photoMap = new Map(); // Use a Map to deduplicate by photo ID
                        
                        for (let i = 0; i < markers.length; i++) {
                            if (markers[i].photoData) {
                                const photo = markers[i].photoData;
                                // Use photo ID or filename as unique key
                                const photoKey = photo.id || photo.filename;
                                
                                // Only add if not already in the map
                                if (!photoMap.has(photoKey)) {
                                    photoMap.set(photoKey, photo);
                                } else {
                                    debugLog(`Skipping duplicate photo: ${photoKey}`);
                                }
                            }
                        }
                        
                        // Convert Map values to array
                        const photos = Array.from(photoMap.values());

                        if (photos.length > 0) {
                            debugLog(`Opening viewer with ${photos.length} unique photos (from ${markers.length} markers)`);

                            // Force display
                            photoViewerOverlay.style.display = 'flex';
                            currentClusterPhotos = photos;
                            currentPhotoIdx = 0;
                            totalPhotos.textContent = photos.length;
                            updatePhotoViewerContent();
                        }
                    } catch (error) {
                        debugLog('ERROR: ' + error.message);
                    }
                });

                debugLog('Direct cluster click handler added');
            } else {
                debugLog('ERROR: MarkerGroup not available');
            }
        }

        function createLibraryFilters(libraries) {
    const container = document.getElementById('libraryFilterContainer');
    const selectAllCheckbox = document.getElementById('selectAllLibraries');

    // Clear any existing filters
    container.innerHTML = '';

    if (!libraries || libraries.length === 0) {
        container.innerHTML = '<p>No libraries available</p>';
        return;
    }

    // Add individual library checkboxes
    libraries.forEach(library => {
        const libraryPhotos = photoData.photos.filter(photo => photo.library_id === library.id);
        const geotaggedCount = libraryPhotos.filter(photo =>
            photo.latitude != null && photo.longitude != null).length;

        const div = document.createElement('div');
        div.className = 'library-checkbox';

        // Create checkbox input
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `library-${library.id}`;
        checkbox.checked = true;
        checkbox.dataset.libraryId = library.id;
        checkbox.className = 'library-filter';

        // Create label
        const label = document.createElement('label');
        label.htmlFor = `library-${library.id}`;
        label.className = 'library-label';

        // Add update time data if available
        // First check if the library object has the last_updated field directly from API
        if (library.last_updated) {
            label.dataset.updateTime = library.last_updated;
        }
        // Fall back to the window.libraryUpdateTimes from legacy API
        else if (window.libraryUpdateTimes && window.libraryUpdateTimes[library.name]) {
            label.dataset.updateTime = window.libraryUpdateTimes[library.name];
        }

        // Create text nodes and count span
        const nameText = document.createTextNode(library.name + ' ');
        const countSpan = document.createElement('span');
        countSpan.className = 'library-count';
        countSpan.textContent = `(${geotaggedCount} photos)`;

        // Build the label structure
        label.appendChild(nameText);
        label.appendChild(countSpan);

        // Build the checkbox div
        div.appendChild(checkbox);
        div.appendChild(label);

        // Add to container
        container.appendChild(div);

        // Add event listener
        checkbox.addEventListener('change', updateLibrarySelection);
    });

    // Add "Select All" functionality
    selectAllCheckbox.addEventListener('change', function() {
        const isChecked = selectAllCheckbox.checked;
        document.querySelectorAll('.library-filter').forEach(cb => {
            cb.checked = isChecked;
        });
        updateLibrarySelection();
    });

    // Initial update
    updateLibrarySelection();

    // Apply tooltips to library labels
    updateLibraryLabelsWithTooltips();
}

        function updateLibrarySelection() {
            // Update which libraries are selected
            const selectedLibraries = [];
            document.querySelectorAll('.library-filter:checked').forEach(checkbox => {
                selectedLibraries.push(parseInt(checkbox.dataset.libraryId));
            });

            photoData.activeLibraries = selectedLibraries;

            // Update the "Select All" checkbox state
            const allLibrariesCheckbox = document.getElementById('selectAllLibraries');
            const allLibraries = document.querySelectorAll('.library-filter');
            const selectedCount = document.querySelectorAll('.library-filter:checked').length;

            if (selectedCount === 0) {
                allLibrariesCheckbox.checked = false;
                allLibrariesCheckbox.indeterminate = false;
            } else if (selectedCount === allLibraries.length) {
                allLibrariesCheckbox.checked = true;
                allLibrariesCheckbox.indeterminate = false;
            } else {
                allLibrariesCheckbox.indeterminate = true;
            }

            // Filter photos based on selected libraries
            filterAndUpdateMap();
        }

        function filterAndUpdateMap() {
            if (!photoData || !photoData.photos) return;

            // Get all photos from active libraries
            let filteredPhotos = photoData.photos.filter(photo =>
                photoData.activeLibraries.includes(photo.library_id) &&
                photo.latitude != null && photo.longitude != null
            );

            debugLog(`Filtered to ${filteredPhotos.length} photos from ${photoData.activeLibraries.length} libraries`);

            // Update photo count display
            photoCountElement.textContent = `${filteredPhotos.length} photos with location`;

            // Update map visualization
            updateHeatmap(filteredPhotos);

            if (showMarkersCheckbox.checked) {
                updateMarkers(filteredPhotos);
            }
        }

        // Add this after your other DOM element declarations
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        // Fullscreen functionality
        fullscreenBtn.addEventListener('click', function () {
            const mapContainer = document.getElementById('map');

            if (!document.fullscreenElement) {
                if (mapContainer.requestFullscreen) {
                    mapContainer.requestFullscreen();
                } else if (mapContainer.webkitRequestFullscreen) { /* Safari */
                    mapContainer.webkitRequestFullscreen();
                } else if (mapContainer.msRequestFullscreen) { /* IE11 */
                    mapContainer.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        });

        // Handle fullscreen change events to update button text
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('msfullscreenchange', updateFullscreenButton);

        function updateFullscreenButton() {
            if (document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement) {
                fullscreenBtn.textContent = 'Exit Fullscreen';
            } else {
                fullscreenBtn.textContent = 'Fullscreen';
            }
        }    </script>

    <script>
        // Global variable to store library update times
        window.libraryUpdateTimes = {};

        // Function to fetch library update times
        function fetchLibraryUpdateTimes() {
            fetch('/library_updates')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    throw new Error('Network response was not ok');
                })
                .then(data => {
                    if (data && data.updates) {
                        window.libraryUpdateTimes = data.updates;
                        console.log('Library update times loaded:', window.libraryUpdateTimes);

                        // Update any existing library labels with tooltips
                        updateLibraryLabelsWithTooltips();
                    }
                })
                .catch(error => {
                    console.error('Error loading library update times:', error);
                });
        }

        // Function to update library labels with tooltips
        function updateLibraryLabelsWithTooltips() {
            // Find all library labels and update them with tooltip data
            document.querySelectorAll('.library-label').forEach(label => {
                const libraryName = label.textContent.trim().split(' ')[0]; // Get just the library name
                if (window.libraryUpdateTimes[libraryName]) {
                    label.setAttribute('data-update-time', window.libraryUpdateTimes[libraryName]);                    
                }
            });
        }

        // Call the function when the document is loaded and then periodically
        document.addEventListener('DOMContentLoaded', () => {
            fetchLibraryUpdateTimes();
            setInterval(fetchLibraryUpdateTimes, 60000); // Update every minute
        });    </script>
    <!-- Library updates are now displayed as tooltips when hovering over library names -->
</body>

</html>