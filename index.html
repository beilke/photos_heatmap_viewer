<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Photo Heatmap Viewer - Simplified</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <!-- Add MarkerCluster if you want clustering -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="static/style.css" />    
</head>

<body>
    <div id="map"></div>
    <div class="controls-container">
        <div class="controls-toggle" id="controlsToggle" aria-controls="controlsPanel" aria-expanded="false">
            <span>Heatmap</span>
            <span class="toggle-icon">▲</span>
        </div>
        <div class="controls" id="controlsPanel" style="display: none;">
            <div>
                <label for="intensity">Intensity: <span id="intensityValue">15</span></label>
                <input type="range" id="intensity" min="1" max="30" value="15">
            </div>
            <div>
                <label for="radius">Radius: <span id="radiusValue">25</span></label>
                <input type="range" id="radius" min="5" max="50" value="25">
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="showMarkers" checked>
                <label for="showMarkers">Show Markers</label>
            </div>
            <div class="library-filters">
                <h4>Libraries</h4>
                <div class="checkbox-container">
                    <input type="checkbox" id="selectAllLibraries" checked>
                    <label for="selectAllLibraries"><strong>All Libraries</strong></label>
                </div>
                <div id="libraryFilterContainer" style="padding-left: 0; margin-left: 0;">
                    <!-- Library filters will be added here dynamically -->
                </div>
            </div>

            <!-- Update Map button removed - changes now apply automatically -->

            <div id="photoCount"></div>
        </div>
    </div>
    <div class="debug-panel-container">
        <div class="debug-panel-toggle" id="debugPanelToggle">
            <span>Debug Info</span>
            <span class="toggle-icon">▲</span>
        </div>
        <div class="debug-panel" id="debugPanel"></div>
    </div>
    <div class="loading" id="loading">
        <h2>Loading Photo Data</h2>
        <p id="loadingMessage">Initializing...</p>
        <div class="progress-bar" id="loadingProgress">
            <div id="progressBar" style="width: 0%;"></div>
        </div>
    </div>

    <!-- Photo Viewer Dialog -->
    <div id="photoViewerOverlay" class="photo-viewer-overlay">
        <div class="photo-viewer-container">
            <div class="photo-viewer-header">
                <div class="photo-viewer-title">Photo Viewer</div>
                <button class="photo-viewer-close" id="closePhotoViewer">&times;</button>
            </div>
            <div class="photo-viewer-content">
                <div class="photo-viewer-image">
                    <img id="photoViewerImg" src="" alt="Photo">                    
                    <div class="image-navigation">
                        <div class="photo-viewer-counter">
                            <span id="currentPhotoIndex">1</span> / <span id="totalPhotos">1</span>
                        </div>
                        <div class="nav-buttons">
                            <button id="prevPhotoBtn" class="photo-nav-btn" aria-label="Previous photo">&lt;</button>
                            <button id="nextPhotoBtn" class="photo-nav-btn" aria-label="Next photo">&gt;</button>
                        </div>
                    </div>
                </div>
                <div class="photo-viewer-info">
                    <div class="photo-viewer-detail">
                        <div class="photo-info-item">
                            <div class="photo-info-label">Filename:</div>
                            <div id="photoInfoFilename"></div>
                        </div>
                        <div class="photo-info-item">
                            <div class="photo-info-label">Date:</div>
                            <div id="photoInfoDate"></div>
                        </div>
                        <div class="photo-info-item">
                            <div class="photo-info-label">Location:</div>
                            <div id="photoInfoLocation"></div>
                        </div>                        
                    </div>
                </div>
            </div>
            <div class="photo-viewer-footer">
                <div class="photo-info-item">
                    <div class="photo-info-label">Path:</div>
                    <div id="photoInfoPath"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Add panel toggle functionality
        // Mobile detection is already done before map initialization
        
        document.addEventListener('DOMContentLoaded', function () {
            // Set mobile-specific body class
            if (isMobile) {
                document.body.classList.add('mobile-device');
            }
            
            // Debug panel toggle - only setup for desktop, on mobile it's hidden
            if (!isMobile) {
                const debugPanelToggle = document.getElementById('debugPanelToggle');
                if (debugPanelToggle) {
                    debugPanelToggle.addEventListener('click', function () {
                        const debugPanel = document.getElementById('debugPanel');
                        const toggleIcon = this.querySelector('.toggle-icon');

                        if (debugPanel.style.display === 'block') {
                            debugPanel.style.display = 'none';
                            toggleIcon.textContent = '▲';
                        } else {
                            debugPanel.style.display = 'block';
                            toggleIcon.textContent = '▼';
                        }
                    });
                }
            }
            
            // Controls panel toggle
            const controlsToggle = document.getElementById('controlsToggle');
            if (controlsToggle) {
                // Initialize the toggle text based on initial state
                const controlsPanel = document.getElementById('controlsPanel');
                const toggleIcon = controlsToggle.querySelector('.toggle-icon');
                
                // Always ensure toggle is visible
                controlsToggle.style.display = 'flex';
                
                // On mobile, start with panel hidden and update toggle icon
                if (isMobile) {
                    controlsPanel.style.display = 'none';
                    toggleIcon.textContent = '▲';
                    controlsToggle.setAttribute('aria-expanded', 'false');
                    controlsPanelVisible = false;
                }
                
                // Use touchend for mobile and click for desktop
                const toggleEvent = isMobile ? 'touchend' : 'click';
                controlsToggle.addEventListener(toggleEvent, function (e) {
                    if (isMobile) {
                        e.preventDefault();
                        e.stopPropagation(); // Prevent event bubbling
                    }
                    
                    if (controlsPanel.style.display === 'block') {
                        controlsPanel.style.display = 'none';
                        toggleIcon.textContent = '▲';
                        this.setAttribute('aria-expanded', 'false');
                        controlsPanelVisible = false;
                    } else {
                        controlsPanel.style.display = 'block';
                        toggleIcon.textContent = '▼';
                        this.setAttribute('aria-expanded', 'true');
                        controlsPanelVisible = true;
                        
                        // Adjust panel height based on content
                        if (isMobile) {
                            // Wait for panel to render before measuring
                            setTimeout(() => {
                                const contentHeight = controlsPanel.scrollHeight;
                                const viewportHeight = window.innerHeight;
                                const maxAllowed = Math.min(contentHeight + 20, viewportHeight * 0.7);
                                controlsPanel.style.maxHeight = maxAllowed + 'px';
                            }, 50);
                        }
                    }
                });
            }
        });

        // Detect if we're on mobile (defined early so we can use it everywhere)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Track visibility states (helps with orientation changes)
        let controlsPanelVisible = false;
        
        // Immediately apply class to body for mobile-specific CSS
        if (isMobile) {
            document.body.classList.add('mobile-device');
            
            // Set controls container position immediately
            const controlsContainer = document.querySelector('.controls-container');
            if (controlsContainer) {
                controlsContainer.style.position = 'fixed';
                controlsContainer.style.bottom = '0';
                controlsContainer.style.top = 'auto';
                controlsContainer.style.left = '0';
                controlsContainer.style.right = '0';
                controlsContainer.style.width = '100%';
                controlsContainer.style.zIndex = '1001';
            }
        }
        
        // Debug logging function - defined based on device type
        let debugLog;
        if (isMobile) {
            // Simpler logging for mobile (console only)
            debugLog = function(message, data) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`, data || '');
            };
        } else {
            // Full logging with UI panel for desktop
            debugLog = function(message, data) {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`, data || '');
                
                const panel = document.getElementById('debugPanel');
                if (panel) {
                    let dataText = '';
                    if (data) {
                        try {
                            dataText = typeof data === 'object' ?
                                `<pre>${JSON.stringify(data, null, 2)}</pre>` :
                                `<pre>${data}</pre>`;
                        } catch (e) {
                            dataText = '<pre>[Complex object]</pre>';
                        }
                    }
                    panel.innerHTML += `<div><strong>[${timestamp}]</strong> ${message} ${dataText}</div>`;
                    panel.scrollTop = panel.scrollHeight;
                }
            };
        }
        
        // Catch all errors
        window.addEventListener('error', function (e) {
            debugLog('ERROR: ' + e.message);
            return false;
        });
        
        // Handle runtime.lastError in browsers
        // This is needed to suppress "Unchecked runtime.lastError" messages
        window.addEventListener('error', function(e) {
            // Check if it's a runtime.lastError
            if (e && e.message && e.message.includes('runtime.lastError')) {
                // Suppress the error
                e.stopPropagation();
                return true; // Prevents the error from showing in console
            }
        });
        
        // Hide debug panel and toggle on mobile devices
        if (isMobile) {
            const debugPanelContainer = document.querySelector('.debug-panel-container');
            if (debugPanelContainer) {
                debugPanelContainer.style.display = 'none';
            }
        }
        
        // Improve touch handling
        if (isMobile) {
            // Fix map dragging issues by preventing unwanted touch event handling
            document.addEventListener('touchmove', function(e) {
                // Allow touch events inside controls and modals
                if (e.target.closest('.controls') || 
                    e.target.closest('.debug-panel') || 
                    e.target.closest('.photo-viewer-container')) {
                    return; // Don't interfere with scrolling in controls
                }
                
                // Let map handle all its own touch events
                if (e.target.closest('#map') || e.target.closest('.leaflet-container')) {
                    // Don't preventDefault - let Leaflet handle its own events
                    return;
                }
            }, { passive: true });
            
            // Ensure map gets proper touch events
            const mapElement = document.getElementById('map');
            if (mapElement) {
                // Force map to handle touch events properly
                mapElement.style.touchAction = 'none';
            }
        }
        
        // Handle device orientation changes and resizing
        function handleViewportChange() {
            // Add a small delay to allow the browser to complete the orientation change
            setTimeout(function() {
                map.invalidateSize();
                
                // Make sure our toggle is still visible after orientation change
                const controlsToggle = document.getElementById('controlsToggle');
                if (controlsToggle) {
                    controlsToggle.style.display = 'flex'; // Ensure toggle is visible
                }
                
                // Update the controls panel display based on our tracking variable
                const controlsPanel = document.getElementById('controlsPanel');
                if (controlsPanel) {
                    controlsPanel.style.display = controlsPanelVisible ? 'block' : 'none';
                }
                
                // Ensure controls container is at the bottom in mobile view
                if (isMobile) {
                    const controlsContainer = document.querySelector('.controls-container');
                    if (controlsContainer) {
                        controlsContainer.style.bottom = '0';
                        controlsContainer.style.top = 'auto';
                    }
                }
                
                debugLog('Viewport changed, map and controls updated');
            }, 300);
        }
        
        // Listen for both orientation and resize changes
        window.addEventListener('orientationchange', handleViewportChange);
        window.addEventListener('resize', handleViewportChange);
        
        // Initialize map
        debugLog('Initializing map');
        if (isMobile) {
            debugLog('Mobile device detected, optimizing layout');
            document.body.classList.add('mobile-device');
        }
        debugLog('Mobile device detected: ' + isMobile);
        
        // Create a map with proper handling of world bounds
        const map = L.map('map', {
            minZoom: 2,
            maxZoom: 19,
            // Use standard Mercator projection bounds
            maxBounds: [
                [-85.06, -180],  // Southwest corner - precise limit for Mercator projection
                [85.06, 180]     // Northeast corner
            ],
            worldCopyJump: true,  // Enable smoother panning across date line
            maxBoundsViscosity: 1.0,  // Keep the user within bounds
            tap: true, // Always enable tap handler
            dragging: true, // Enable dragging for all devices
            touchZoom: true, // Enable touch zoom
            tapTolerance: 15, // Increased tap tolerance for mobile
            bounceAtZoomLimits: false // Prevent bounce when hitting zoom limits
        }).setView([0, 0], isMobile ? 2 : 2); // Start with a zoomed-out world view

        
        // Custom wrapper for OpenStreetMap tiles that handles coordinate wrapping properly
        const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: 'abc',
            minZoom: 2,
            maxZoom: 19,
            noWrap: false,  // Allow wrapping for better UX
            // Custom tile error handler
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
        }).addTo(map);

        // Add event listener to catch and handle tile loading errors
        tileLayer.on('tileerror', function(e) {
            // Prevent console errors for out-of-range tiles
            debugLog(`Tile error suppressed: z=${e.coords.z}, x=${e.coords.x}, y=${e.coords.y}`);
            return true; // Suppress error
        });
        
        // Global variables
        let photoData = [];
        let filteredData = [];
        let heatLayer = null;
        let markerGroup = null;

        // Photo viewer variables
        let currentClusterPhotos = [];
        let currentPhotoIdx = 0;

        // DOM elements
        const intensitySlider = document.getElementById('intensity');
        const radiusSlider = document.getElementById('radius');
        const showMarkersCheckbox = document.getElementById('showMarkers');
        const updateMapButton = document.getElementById('updateMap');
        const photoCountElement = document.getElementById('photoCount');
        const loadingElement = document.getElementById('loading');
        // Photo viewer DOM elements
        const photoViewerOverlay = document.getElementById('photoViewerOverlay');
        const photoViewerImg = document.getElementById('photoViewerImg');
        const photoInfoFilename = document.getElementById('photoInfoFilename');
        const photoInfoDate = document.getElementById('photoInfoDate');
        const photoInfoLocation = document.getElementById('photoInfoLocation');
        const photoInfoPath = document.getElementById('photoInfoPath');
        const currentPhotoIndex = document.getElementById('currentPhotoIndex');
        const totalPhotos = document.getElementById('totalPhotos');
        const prevPhotoBtn = document.getElementById('prevPhotoBtn');
        const nextPhotoBtn = document.getElementById('nextPhotoBtn');
        const closePhotoViewerBtn = document.getElementById('closePhotoViewer');

        // No image transformation controls needed

        // Load photo data
        function loadPhotoData() {
            debugLog('Loading photo data');

            // Show loading indicator with progress bar
            loadingElement.style.display = 'flex';
            const loadingMessage = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('progressBar');
            
            // Initialize loading state
            loadingMessage.textContent = 'Fetching photo data...';
            progressBar.style.width = '10%';
            // Use the new API endpoint for markers
            fetch('/api/markers')
                .then(response => {
                    debugLog(`Response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.text().then(text => {
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            debugLog(`JSON parse error: ${e.message}`);
                            debugLog(`JSON content (first 200 chars): ${text.substring(0, 200)}`);
                            throw new Error(`JSON parse error: ${e.message}`);
                        }
                    });
                }).then(data => {
                    // Handle both new and legacy JSON formats
                    let photos = [];
                    let libraries = [];

                    if (Array.isArray(data)) {
                        // Legacy format (just an array of photos)
                        photos = data;
                        debugLog(`Loaded ${photos.length} photos (legacy format)`);
                    } else {
                        // New format with photos and libraries
                        photos = data.photos || [];
                        libraries = data.libraries || [];
                        debugLog(`Loaded ${photos.length} photos from ${libraries.length} libraries`);

                        // Log libraries if available
                        if (libraries.length > 0) {
                            debugLog(`Available libraries: ${libraries.map(lib => lib.name).join(', ')}`);
                        }
                    }

                    // Store data globally
                    photoData = {
                        photos: photos,
                        libraries: libraries,
                        activeLibraries: libraries.map(lib => lib.id) // Start with all libraries active
                    };

                    // Create library filter controls
                    createLibraryFilters(libraries);

                    // Count photos with GPS coords
                    const withGPS = photos.filter(photo =>
                        photo.latitude != null && photo.longitude != null);
                    debugLog(`Photos with GPS: ${withGPS.length}/${photos.length}`);

                    // Update photo count display
                    photoCountElement.textContent = `${withGPS.length} photos with location`;

                    // Unified loading sequence with progress updates
                    const progressBar = document.getElementById('progressBar');
                    const loadingMessage = document.getElementById('loadingMessage');
                    
                    // Update loading state (30% progress)
                    progressBar.style.width = '30%';
                    loadingMessage.textContent = 'Processing photo data...';
                    
                    setTimeout(() => {
                        // Step 1: Create heatmap (50% progress)
                        loadingMessage.textContent = 'Creating heatmap...';
                        progressBar.style.width = '50%';
                        
                        updateHeatmap(withGPS);
                        if (withGPS.length > 0) {
                            try {
                                // Group points by which side of the antimeridian they fall on
                                const western = [];
                                const eastern = [];
                                
                                withGPS.forEach(photo => {
                                    // Clamp latitude to Mercator projection limits
                                    const lat = Math.max(-85.06, Math.min(85.06, photo.latitude));
                                    // Normalize longitude 
                                    const lng = ((photo.longitude + 180) % 360) - 180;
                                    
                                    // Group points by hemisphere to detect antimeridian crossings
                                    if (lng < 0) {
                                        western.push([lat, lng]);
                                    } else {
                                        eastern.push([lat, lng]);
                                    }
                                });
                                
                                // Handle antimeridian crossing (points on both sides of the world)
                                // If we have significant numbers of points in both hemispheres, zoom out to global view
                                const hasAntimeridianCrossing = 
                                    western.length > 5 && eastern.length > 5 && 
                                    ((western.length / withGPS.length) > 0.1) && 
                                    ((eastern.length / withGPS.length) > 0.1);
                                
                                if (hasAntimeridianCrossing) {
                                    // If data spans the antimeridian, show world view instead of a wrapped view
                                    debugLog('Data spans both sides of the world, using global view');
                                    map.setView([0, 0], 2);
                                } else {
                                    // Create bounds normally if no antimeridian issues
                                    const points = withGPS.map(photo => [
                                        // Clamp latitude to Mercator projection limits
                                        Math.max(-85.06, Math.min(85.06, photo.latitude)),
                                        // Normalize longitude to avoid invalid coordinates
                                        ((photo.longitude + 180) % 360) - 180
                                    ]);
                                    
                                    // Calculate bounds
                                    const bounds = L.latLngBounds(points);
                                    
                                    // Ensure bounds are valid and not too small
                                    if (bounds.isValid() && bounds.getNorth() - bounds.getSouth() > 0.01) {
                                        debugLog(`Fitting map to bounds: ${bounds.toBBoxString()}`);
                                        // Add safety check for very wide bounds
                                        const isVeryWide = (bounds.getEast() - bounds.getWest()) > 270;
                                        
                                        // If bounds are too wide (nearly global), use a global view
                                        if (isVeryWide) {
                                            debugLog('Bounds too wide, using global view');
                                            map.setView([0, 0], 2);
                                        } else {
                                            // Otherwise fit to the calculated bounds
                                            map.fitBounds(bounds, { 
                                                padding: [50, 50],
                                                maxZoom: 12, // Prevent zooming in too far on small clusters
                                                animate: true,
                                                duration: 1 // quick animation
                                            });
                                        }
                                    } else {
                                        // Fallback to default view if bounds are invalid or too small
                                        debugLog('Invalid or too small bounds, using default view');
                                        map.setView([0, 0], 2);
                                    }
                                }
                            } catch (e) {
                                debugLog(`Error fitting bounds: ${e.message}`);
                                // Fallback to a safe default view
                                map.setView([0, 0], 2);
                            }
                        }
                        
                        // Step 2: Add markers (70% progress)
                        setTimeout(() => {
                            loadingMessage.textContent = 'Adding photo markers...';
                            progressBar.style.width = '70%';
                            
                            if (showMarkersCheckbox.checked) {
                                // The updateMarkers function will handle the rest of the loading process
                                updateMarkers(withGPS);
                            } else {
                                // If markers not shown, complete loading
                                progressBar.style.width = '95%';
                                loadingMessage.textContent = 'Finalizing...';
                                
                                // Finish loading after a brief delay to show progress
                                setTimeout(() => {
                                    progressBar.style.width = '100%';
                                    loadingMessage.textContent = 'Complete!';
                                    
                                    // Hide the loading screen after a small delay
                                    setTimeout(() => {
                                        loadingElement.style.display = 'none';
                                    }, 500);
                                }, 300);
                            }
                        }, 100);
                    }, 100);
                })
                .catch(error => {
                    debugLog(`Error loading photo data: ${error.message}`);
                    loadingElement.innerHTML = `
                        <h2>Error Loading Data</h2>
                        <p>${error.message}</p>
                        <p class="error-hint">Press F5 to refresh the page</p>
                    `;
                });
        }

        // Update map visualization with progressive loading        
        function updateVisualization() {
            debugLog('Updating visualization');

            const loadingStatus = document.createElement('div');
            loadingStatus.className = 'loading-status';
            loadingStatus.style.cssText = `
                position: absolute;
                bottom: 10px;
                right: 10px;
                background-color: rgba(255,255,255,0.9);
                padding: 10px;
                border-radius: 4px;
                z-index: 1000;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            document.body.appendChild(loadingStatus);

            try {
                // Use the filterAndUpdateMap function which handles active libraries
                filterAndUpdateMap();
            } catch (err) {
                debugLog('Error updating visualization: ' + err.message);
            } finally {
                // Remove loading status
                if (loadingStatus.parentNode) {
                    setTimeout(() => {
                        document.body.removeChild(loadingStatus);
                    }, 500); // Give some time to see the status
                }
            }
        }

        // Update heatmap
        function updateHeatmap(photos) {
            debugLog('Updating heatmap');

            // Remove existing heatmap if present
            if (heatLayer) {
                map.removeLayer(heatLayer);
            }

            // Create heatmap points with varying intensity based on the slider
            const intensityValue = parseInt(intensitySlider.value);
            // Use slider value as weight multiplier for each point
            const points = photos.map(photo => [
                photo.latitude,
                photo.longitude,
                intensityValue / 10  // Use intensity slider to affect point weights
            ]);

            debugLog(`Setting heatmap with point weight: ${intensityValue / 10} (from intensity value: ${intensityValue})`);
            
            heatLayer = L.heatLayer(points, {
                radius: parseInt(radiusSlider.value),
                blur: 15,
                maxZoom: 10,
                gradient: { 0.4: 'blue', 0.65: 'lime', 1: 'red' }
                // Note: Leaflet.heat doesn't use an "intensity" param directly, 
                // instead we modify the point weights above
            }).addTo(map);

            debugLog(`Heatmap created with ${points.length} points`);
        }
        
        // Function to update only the heatmap without touching markers
        function updateHeatmapOnly() {
            debugLog('Updating only heatmap with new settings');
            
            // Get the current filtered data based on active libraries
            const filteredPhotos = filterPhotosByActiveLibraries();
            
            // Update just the heatmap with new intensity/radius
            updateHeatmap(filteredPhotos);
            
            debugLog(`Heatmap updated with intensity=${intensitySlider.value}, radius=${radiusSlider.value}`);
        }
        
        // Function to update only markers without touching heatmap
        function updateMarkersOnly() {
            debugLog('Updating only markers');
            
            // Get the current filtered data based on active libraries
            const filteredPhotos = filterPhotosByActiveLibraries();
            
            // Update just the markers
            if (showMarkersCheckbox.checked) {
                // If we already have a marker group, just add it back to the map
                // instead of recreating all markers
                if (markerGroup) {
                    if (!map.hasLayer(markerGroup)) {
                        debugLog('Showing existing marker group');
                        map.addLayer(markerGroup);
                        
                        // Show feedback to user
                        showFeedbackToast('Showing photo markers...');
                    }
                } else {
                    // Only create new markers if we don't have them already
                    updateMarkers(filteredPhotos);
                }
            } else {
                // If markers are turned off, just remove them from the map
                // but keep the marker group in memory
                if (markerGroup && map.hasLayer(markerGroup)) {
                    debugLog('Hiding markers');
                    map.removeLayer(markerGroup);
                    
                    // Show feedback to user
                    showFeedbackToast('Hiding photo markers...');
                }
            }
        }
        
        // Helper function to show feedback toast
        function showFeedbackToast(message) {
            const feedback = document.createElement('div');
            feedback.className = 'feedback-toast';
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.7);
                color: white;
                padding: 8px 15px;
                border-radius: 4px;
                font-size: 14px;
                z-index: 1500;
            `;
            document.body.appendChild(feedback);
            
            // Remove feedback after a short delay
            setTimeout(() => feedback.remove(), 1500);
        }
        
        // Filter photos by currently active libraries
        function filterPhotosByActiveLibraries() {
            if (!photoData || !photoData.photos || photoData.photos.length === 0) {
                debugLog('No photo data available to filter');
                return [];
            }
            
            // If we don't have library info, just return all photos
            if (!photoData.libraries || !photoData.activeLibraries) {
                return photoData.photos.filter(photo => 
                    photo.latitude != null && photo.longitude != null
                );
            }
            
            // Filter by active libraries
            return photoData.photos.filter(photo => {
                // Filter out photos without GPS
                if (photo.latitude == null || photo.longitude == null) {
                    return false;
                }
                
                // If no library_id, include it if we don't have library filters
                if (photo.library_id == null) {
                    return true;
                }
                
                // Otherwise, check if photo's library is active
                return photoData.activeLibraries.includes(photo.library_id);
            });
        }
        
        
        // Update markers
        function updateMarkers(inputPhotos = []) {
    debugLog('Updating markers');

    // Deduplicate photos
    const photoMap = new Map();
    inputPhotos.forEach(photo => {
        const photoKey = photo.id || `${photo.latitude}_${photo.longitude}_${photo.filename}`;
        if (!photoMap.has(photoKey)) {
            photoMap.set(photoKey, photo);
        }
    });
    const uniquePhotos = Array.from(photoMap.values());
    const dupesRemoved = inputPhotos.length - uniquePhotos.length;

    if (dupesRemoved > 0) {
        debugLog(`Removed ${dupesRemoved} duplicate photos before creating markers`);
    }

    const filteredPhotos = uniquePhotos;
    debugLog(`Loading markers for ${filteredPhotos.length} unique photos...`);

    // Update the main loading indicator instead of creating a new one
    const loadingElement = document.getElementById('loading');
    const loadingMessage = document.getElementById('loadingMessage');
    const progressBar = document.getElementById('progressBar');
    
    // Make sure loading indicator is visible
    if (loadingElement) {
        loadingElement.style.display = 'flex';
    }
    
    if (loadingMessage) {
        loadingMessage.textContent = 'Loading markers...';
    }
    
    if (progressBar) {
        progressBar.style.width = '70%';
    }

    // Remove old markers
    if (typeof markerGroup !== 'undefined' && markerGroup) {
        map.removeLayer(markerGroup);
        markerGroup = null; // Explicitly null it out to ensure full recreation
    }

    // Create new marker group
    try {
        markerGroup = typeof L.markerClusterGroup === 'function'
            ? L.markerClusterGroup()
            : L.layerGroup();

        // We don't add the clusterclick handler here anymore
        // The handler is added once after all markers are created
        // to prevent duplicates and ensure proper behavior
    } catch (err) {
        debugLog('Error creating marker group: ' + err.message);
        markerGroup = L.layerGroup();
    }

    // Process markers (chunked if large dataset)
    const chunkSize = 100;
    let currentChunk = 0;
    
    // Handle empty filtered photos case
    if (filteredPhotos.length === 0) {
        debugLog('No photos with GPS data to display');
        loadingMessage.textContent = 'No photos with GPS data to display';
        
        // Staged progress for better UX
        progressBar.style.width = '90%';
        
        // Briefly show the message, then finish loading
        setTimeout(() => {
            progressBar.style.width = '100%';
            loadingMessage.textContent = 'Complete!';
            
            // Hide loading screen after a short delay
            setTimeout(() => {
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }, 800);
        }, 800);
        return;
    }
    
    const totalChunks = Math.ceil(filteredPhotos.length / chunkSize);

    function processChunk() {
        const start = currentChunk * chunkSize;
        const end = Math.min(start + chunkSize, filteredPhotos.length);

        for (let i = start; i < end; i++) {
            addMarker(filteredPhotos[i]);
        }

        // Calculate percentage completed and adjust scale to fit in 70-95% range
        // Only going to 95% to leave the last 5% for the final rendering
        const percentComplete = Math.min(100, Math.round((end / filteredPhotos.length) * 100));
        loadingMessage.textContent = `Loading markers: ${percentComplete}%`;
        
        // Scale from 70-95% for marker loading instead of going straight to 100%
        // This leaves room for the final marker rendering step
        const progressWidth = 70 + (percentComplete * 0.25); // Progress from 70% to 95%
        progressBar.style.width = `${progressWidth}%`;

        currentChunk++;
        if (currentChunk < totalChunks) {
            setTimeout(processChunk, 20);
        } else {
            finishMarkerLoading();
        }
    }

    if (filteredPhotos.length > 500) {
        debugLog(`Using chunked processing for ${filteredPhotos.length} markers`);
        processChunk();
    } else {
        if (filteredPhotos.length > 0) {
            // For smaller batches, show that we're at 80% progress while processing
            loadingMessage.textContent = `Loading ${filteredPhotos.length} markers...`;
            progressBar.style.width = '80%';
            
            // Small delay to ensure the UI updates before potentially heavy processing
            setTimeout(() => {
                filteredPhotos.forEach(photo => addMarker(photo));
                finishMarkerLoading();
            }, 50);
        } else {
            finishMarkerLoading();
        }
    }

    function addMarker(photo) {
        if (photo.latitude == null || photo.longitude == null) {
            debugLog(`Skipping photo with invalid coordinates: ${photo.filename}`);
            return;
        }

        const marker = L.marker([photo.latitude, photo.longitude]);
        marker.photoData = photo;

        const container = document.createElement('div');
        container.className = 'marker-popup';
        container.innerHTML = `
            <strong>${photo.filename || 'Unknown'}</strong><br>
            ${photo.datetime ? new Date(photo.datetime).toLocaleString() : 'No date'}<br>
            <div class="popup-image-container" style="width: 150px; height: 150px; background: #f0f0f0; display: flex; align-items: center; justify-content: center;">
                <span class="loading-placeholder">Loading...</span>
            </div>
        `;

        marker.bindPopup(container);

        marker.on('popupopen', function () {
            const imageContainer = container.querySelector('.popup-image-container');
            if (!imageContainer.querySelector('img')) {
                const img = new Image();
                img.style.maxWidth = '150px';
                img.style.maxHeight = '150px';

                img.onload = function () {
                    imageContainer.innerHTML = '';
                    imageContainer.appendChild(img);
                };

                img.onerror = function () {
                    imageContainer.innerHTML = 'Image not available';
                    debugLog(`Failed to load popup image for ${photo.filename}`);
                };

                img.src = `/photos/${encodeURIComponent(photo.filename)}`;
            }
        });

        marker.on('click', function (e) {
            // Find all photos at exactly the same coordinates using what's available in photoData
            // rather than depending on the outer scope's filteredPhotos
            const currentPhotos = filterPhotosByActiveLibraries();
            let photosAtSameLocation = currentPhotos.filter(p =>
                p.latitude === photo.latitude && p.longitude === photo.longitude
            );

            // Log the found photos for verification
            debugLog(`Found ${photosAtSameLocation.length} photos at location ${photo.latitude},${photo.longitude}`);
            
            const locationMap = new Map();
            photosAtSameLocation.forEach(p => {
                // Create a more precise unique key including coordinates
                const key = p.id || `${p.filename}_${p.latitude}_${p.longitude}`;
                if (!locationMap.has(key)) {
                    // Ensure all path info is available
                    if (p.path && !p.full_path) {
                        p.full_path = p.path;
                    }
                    locationMap.set(key, p);
                    debugLog(`Location photo: ${p.filename}`);
                }
            });
            photosAtSameLocation = Array.from(locationMap.values());

            debugLog(`Marker clicked: ${photo.filename} (${photosAtSameLocation.length} unique photos at this location)`);

            const index = photosAtSameLocation.findIndex(p =>
                p.id === photo.id || p.filename === photo.filename
            );

            openPhotoViewer(photosAtSameLocation, index >= 0 ? index : 0);
            e.originalEvent?.stopPropagation();
            L.DomEvent.stopPropagation(e);
        });

        markerGroup.addLayer(marker);
    }

    function finishMarkerLoading() {
        map.addLayer(markerGroup);
        
        // Add the cluster click handler here to ensure it's only added once
        // after all markers are processed
        if (markerGroup && markerGroup.on) {
            // Remove any existing handlers first to prevent duplicates
            if (typeof markerGroup.off === 'function') {
                markerGroup.off('clusterclick');
            }
            
            // Add our handler with proper photo filtering
            markerGroup.on('clusterclick', function (e) {
                try {
                    const cluster = e.layer;
                    const markers = cluster.getAllChildMarkers();
                    const clusterCount = markers.length;
                    
                    debugLog(`Cluster clicked: ${clusterCount} markers`);
                    
                    // Use a Map to deduplicate photos by ID
                    const photoMap = new Map();
                    
                    // Process only the markers in this specific cluster
                    markers.forEach(marker => {
                        if (marker.photoData) {
                            const photo = marker.photoData;
                            // Use unique ID or create one from multiple properties for better uniqueness
                            const photoKey = photo.id || `${photo.filename}_${photo.latitude}_${photo.longitude}`;
                            
                            // Only add if not already in map
                            if (!photoMap.has(photoKey)) {
                                // Ensure all path info is available for verification
                                if (photo.path && !photo.full_path) {
                                    photo.full_path = photo.path;
                                }
                                
                                photoMap.set(photoKey, photo);
                                debugLog(`Cluster photo: ${photo.filename}, lat/long: ${photo.latitude}/${photo.longitude}`);
                            }
                        }
                    });
                    
                    // Convert map to array of unique photos
                    const uniquePhotos = Array.from(photoMap.values());
                    
                    if (uniquePhotos.length > 0) {
                        debugLog(`Opening viewer with ${uniquePhotos.length} unique photos from cluster`);
                        openPhotoViewer(uniquePhotos, 0);
                    }
                } catch (err) {
                    debugLog('Error in cluster click handler: ' + err.message);
                }
            });
        }
        
        // Update progress only at the very end when markers are actually added to the map
        progressBar.style.width = '100%';
        loadingMessage.textContent = 'Complete!';
        debugLog('Successfully added markers to map');
        
        // Clean up library selection flag if it exists
        if (window._processingLibrarySelection) {
            window._processingLibrarySelection = false;
        }
        
        // Hide loading screen after a short delay - slightly longer to ensure
        // users see the 100% state before it disappears
        setTimeout(() => {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
        }, 800);
    }
}


        // Photo viewer functions
        function openPhotoViewer(photos, startIndex = 0) {
            if (!photos || photos.length === 0) {
                debugLog('Cannot open photo viewer: No photos provided');
                return;
            }

            debugLog(`Opening photo viewer with ${photos.length} photos, starting at index ${startIndex}`);

            // Handle large clusters more efficiently
            if (photos.length > 100) {
                debugLog(`Large cluster detected (${photos.length} photos). Using optimized handling.`);

                // Only store the first 100 photos for immediate viewing
                // Additional photos will be loaded on demand if user navigates that far
                currentClusterPhotos = [...photos.slice(0, 100)];

                // Store reference to full dataset for paged loading
                currentClusterPhotos.fullDataset = photos;
                currentClusterPhotos.loadedCount = 100;
            } else {
                // For smaller clusters, load all at once
                currentClusterPhotos = [...photos];
            }

            currentPhotoIdx = Math.min(startIndex, currentClusterPhotos.length - 1);
            totalPhotos.textContent = photos.length; // Show total including not-yet-loaded

            updatePhotoViewerContent();
            photoViewerOverlay.style.display = 'flex';
        }
        function closePhotoViewer() {
            debugLog('Closing photo viewer');
            photoViewerOverlay.style.display = 'none';
        }
        
        // Add swipe gesture support for mobile
        if (isMobile) {
            const photoContainer = document.querySelector('.photo-viewer-container');
            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0; 
            let touchEndY = 0;
            
            photoContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });
            
            photoContainer.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                
                // Calculate horizontal and vertical distances
                const horizontalDistance = touchEndX - touchStartX;
                const verticalDistance = Math.abs(touchEndY - touchStartY);
                
                // Only register as swipe if horizontal movement is significant and vertical movement is minimal
                if (Math.abs(horizontalDistance) > 100 && verticalDistance < 50) {
                    if (horizontalDistance > 0) {
                        // Swipe right - show previous photo
                        showPreviousPhoto();
                    } else {
                        // Swipe left - show next photo
                        showNextPhoto();
                    }
                }
            });
        }

        // Constants for virtual scrolling
        const PRELOAD_BATCH_SIZE = 50;
        const MAX_LOADED_PHOTOS = 200;

        function updatePhotoViewerContent() {
            const photo = currentClusterPhotos[currentPhotoIdx];
            if (!photo) {
                debugLog('Cannot update photo viewer: No photo at current index');
                return;
            }
            
            // Set the current photo ID for verification
            photoViewerImg.dataset.loadingPhotoId = photo.id || photo.filename;

            // Virtual scrolling: Manage loaded photos based on current index
            if (currentClusterPhotos.fullDataset) {
                const totalPhotos = currentClusterPhotos.fullDataset.length;
                const currentLoadedCount = currentClusterPhotos.length;

                // Calculate the window of photos we want to keep loaded
                const windowStart = Math.max(0, currentPhotoIdx - Math.floor(MAX_LOADED_PHOTOS / 2));
                const windowEnd = Math.min(totalPhotos, windowStart + MAX_LOADED_PHOTOS);

                // Load more photos if we're approaching the end of our loaded set
                if (currentPhotoIdx > currentLoadedCount - PRELOAD_BATCH_SIZE &&
                    currentLoadedCount < totalPhotos) {

                    const nextBatchSize = Math.min(PRELOAD_BATCH_SIZE,
                        totalPhotos - currentLoadedCount);

                    debugLog(`Loading next batch of ${nextBatchSize} photos (${currentLoadedCount + 1}-${currentLoadedCount + nextBatchSize} of ${totalPhotos})`);

                    const nextBatch = currentClusterPhotos.fullDataset.slice(
                        currentLoadedCount,
                        currentLoadedCount + nextBatchSize
                    );

                    currentClusterPhotos.push(...nextBatch);
                    currentClusterPhotos.loadedCount = currentClusterPhotos.length;
                }

                // Remove photos that are far from current index to manage memory
                if (currentClusterPhotos.length > MAX_LOADED_PHOTOS) {
                    const photosToRemove = [];

                    // Remove photos before the window
                    if (windowStart > 0) {
                        photosToRemove.push(...currentClusterPhotos.slice(0, windowStart));
                    }

                    // Remove photos after the window
                    if (windowEnd < currentClusterPhotos.length) {
                        photosToRemove.push(...currentClusterPhotos.slice(windowEnd));
                    }

                    if (photosToRemove.length > 0) {
                        debugLog(`Removing ${photosToRemove.length} photos outside viewing window`);
                        currentClusterPhotos = currentClusterPhotos.filter(p => !photosToRemove.includes(p));
                    }
                }
            }

            debugLog(`Updating photo viewer content to photo ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

            // Update navigation buttons state
            prevPhotoBtn.disabled = currentPhotoIdx <= 0;
            nextPhotoBtn.disabled = currentPhotoIdx >= currentClusterPhotos.length - 1;

            // Update counter
            currentPhotoIndex.textContent = currentPhotoIdx + 1;

            // No image transformations needed
            debugLog(`Loading image for ${photo.filename}`);
            
            // First verify we have a valid filename
            if (!photo.filename) {
                debugLog('Photo missing filename, using placeholder');
                photoViewerImg.src = 'https://placehold.co/800x600?text=Missing+Filename';
                photoViewerImg.style.opacity = '1';
                return;
            }
            
            // OPTIMIZED APPROACH - USE CONVERT ENDPOINT FOR HEIC FILES
            const isHeic = photo.filename.toLowerCase().endsWith('.heic');
            
            // Choose endpoint based on file type:
            // - convert: For HEIC files, gets full resolution but converts to JPEG
            // - photos: For regular images, serves the original file
            const endpoint = isHeic ? '/convert' : '/photos';
            
            // Build URL with ID parameter if available (more reliable than filename alone)
            let fullImageUrl;
            if (photo.id) {
                fullImageUrl = `${endpoint}/${encodeURIComponent(photo.filename)}?id=${encodeURIComponent(photo.id)}`;
                debugLog(`Loading with ID parameter: ${fullImageUrl}`);
            } else if (photo.path) {
                fullImageUrl = `${endpoint}/${encodeURIComponent(photo.filename)}?path=${encodeURIComponent(photo.path)}`;
                debugLog(`Loading with path parameter: ${fullImageUrl}`);
            } else {
                fullImageUrl = `${endpoint}/${encodeURIComponent(photo.filename)}`;
                debugLog(`Loading with basic URL: ${fullImageUrl}`);
            }
            
            // Create new image to preload
            const fullImg = new Image();
            
            fullImg.onload = function() {
                photoViewerImg.src = fullImageUrl;
                photoViewerImg.style.opacity = '1';
                debugLog(`Successfully loaded ${isHeic ? 'converted HEIC' : 'regular'} image: ${photo.filename}`);
                
                // For verification, add a tooltip showing the full path
                if (photo.path) {
                    photoViewerImg.title = `Path: ${photo.path}`;
                }
            };
            
            fullImg.onerror = function() {
                debugLog(`Failed to load ${fullImageUrl}, trying fallback options`);
                
                if (isHeic) {
                    // If convert endpoint failed for HEIC, try thumbnails as fallback
                    const thumbnailUrl = `/thumbnails/${encodeURIComponent(photo.filename)}${photo.id ? '?id=' + encodeURIComponent(photo.id) : ''}`;
                    debugLog(`Trying thumbnail as fallback: ${thumbnailUrl}`);
                    photoViewerImg.src = thumbnailUrl;
                } else if (endpoint === '/photos' && photo.id) {
                    // Try without ID parameter
                    const basicUrl = `/photos/${encodeURIComponent(photo.filename)}`;
                    debugLog(`Trying without parameters: ${basicUrl}`);
                    photoViewerImg.src = basicUrl;
                } else {
                    debugLog(`All attempts failed, using placeholder`);
                    photoViewerImg.src = 'https://placehold.co/800x600?text=Photo+Unavailable';
                    photoViewerImg.style.opacity = '1';
                }
            };
            
            fullImg.src = fullImageUrl;

            // Add error handler for the main viewer image as fallback
            photoViewerImg.onerror = () => {
                debugLog(`Failed to load image for ${photo.filename}, using placeholder`);
                photoViewerImg.src = 'https://placehold.co/800x600?text=Photo+Unavailable';
                photoViewerImg.style.opacity = '1';
            };
            
            // Handle successful load
            photoViewerImg.onload = function () {
                debugLog(`Successfully loaded image for ${photo.filename}, dimensions: ${this.naturalWidth}x${this.naturalHeight}`);
                
                // Check if this is a placeholder image
                if (this.src.includes('placehold.co')) {
                    debugLog(`WARNING: Displaying placeholder because original image couldn't be loaded`);
                }

                // Make sure the image is visible
                this.style.opacity = '1';

                // Reset any previous sizing
                this.style.maxWidth = '';
                this.style.maxHeight = '';
                this.style.width = '';
                this.style.height = '';

                // Calculate aspect ratio
                const aspectRatio = this.naturalWidth / this.naturalHeight;
                const isPortrait = aspectRatio < 1;

                // Set appropriate dimensions based on orientation
                if (isPortrait) {
                    this.style.maxHeight = '85vh';
                    this.style.width = 'auto';
                } else {
                    this.style.maxWidth = '85vw';
                    this.style.height = 'auto';
                }

                debugLog(`Image orientation: ${isPortrait ? 'portrait' : 'landscape'}, aspect ratio: ${aspectRatio.toFixed(2)}`);

                // No image transformations needed
            };


            // Enhanced photo info display with more verification details
            photoInfoFilename.textContent = photo.filename || 'Unknown';
            photoInfoDate.textContent = photo.datetime ? new Date(photo.datetime).toLocaleString() : 'Unknown';
            photoInfoLocation.textContent = (photo.latitude != null && photo.longitude != null) ?
                `${photo.latitude.toFixed(6)}, ${photo.longitude.toFixed(6)}` : 'Not available';
            
            // Show detailed path info to help with verification
            const pathInfo = [];
            if (photo.path) pathInfo.push(`Path: ${photo.path}`);
            if (photo.full_path && photo.full_path !== photo.path) pathInfo.push(`Full path: ${photo.full_path}`);
            if (photo.library_name) pathInfo.push(`Library: ${photo.library_name}`);
            if (photo.id) pathInfo.push(`ID: ${photo.id}`);
            
            photoInfoPath.textContent = pathInfo.length > 0 ? pathInfo.join(' | ') : (photo.path || 'Unknown');
        }
        function showNextPhoto() {
            // Check if we need to load more photos
            if (currentPhotoIdx === currentClusterPhotos.length - 1 &&
                currentClusterPhotos.fullDataset &&
                currentClusterPhotos.loadedCount < currentClusterPhotos.fullDataset.length) {

                // Load next batch of photos
                const nextBatchSize = Math.min(50, currentClusterPhotos.fullDataset.length - currentClusterPhotos.loadedCount);
                debugLog(`Loading next batch of ${nextBatchSize} photos`);

                // Get the next batch
                const nextBatch = currentClusterPhotos.fullDataset.slice(
                    currentClusterPhotos.loadedCount,
                    currentClusterPhotos.loadedCount + nextBatchSize
                );

                // Add to the current set
                currentClusterPhotos.push(...nextBatch);
                currentClusterPhotos.loadedCount += nextBatchSize;

                debugLog(`Now loaded ${currentClusterPhotos.loadedCount} of ${currentClusterPhotos.fullDataset.length} photos`);
            }
            if (currentPhotoIdx < currentClusterPhotos.length - 1) {
                currentPhotoIdx++;
                debugLog(`Moving to next photo: ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

                // Preserve the current image opacity while we load the next one
                photoViewerImg.style.opacity = '0.8';
                updatePhotoViewerContent();
            }
        }
        function showPreviousPhoto() {
            if (currentPhotoIdx > 0) {
                currentPhotoIdx--;
                debugLog(`Moving to previous photo: ${currentPhotoIdx + 1}/${currentClusterPhotos.length}`);

                // Preserve the current image opacity while we load the previous one
                photoViewerImg.style.opacity = '0.8';
                updatePhotoViewerContent();
            }
        }        // Event listeners
        // Automatically update on intensity change (with debounce to prevent too frequent updates)
        let intensityDebounceTimer;
        const intensityValueDisplay = document.getElementById('intensityValue');
        
        intensitySlider.addEventListener('input', function() {
            // Update the display value immediately for better user feedback
            intensityValueDisplay.textContent = this.value;
            
            // Debounce the actual map update to avoid performance issues
            clearTimeout(intensityDebounceTimer);
            intensityDebounceTimer = setTimeout(() => {
                debugLog(`Intensity changed to: ${this.value}`);
                // Only update the heatmap, not the markers
                updateHeatmapOnly();
            }, 300);
        });
        
        // Automatically update on radius change (with debounce)
        let radiusDebounceTimer;
        const radiusValueDisplay = document.getElementById('radiusValue');
        
        radiusSlider.addEventListener('input', function() {
            // Update the display value immediately
            radiusValueDisplay.textContent = this.value;
            
            // Debounce the map update
            clearTimeout(radiusDebounceTimer);
            radiusDebounceTimer = setTimeout(() => {
                debugLog(`Radius changed to: ${this.value}`);
                // Only update the heatmap, not the markers
                updateHeatmapOnly();
            }, 300);
        });

        // Immediately update when "Show Photos Count" checkbox is changed
        showMarkersCheckbox.addEventListener('change', function () {
            debugLog(`Show markers changed: ${this.checked}`);
            
            // Only update markers, not the heatmap - the feedback toast is now handled inside updateMarkersOnly()
            updateMarkersOnly();
        });
        // Photo viewer event listeners
        // Use the appropriate event (touchend for mobile, click for desktop)
        const eventType = isMobile ? 'touchend' : 'click';
        
        closePhotoViewerBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            closePhotoViewer();
        });
        
        prevPhotoBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            showPreviousPhoto();
        });
        
        nextPhotoBtn.addEventListener(eventType, function(e) {
            if (isMobile) e.preventDefault();
            showNextPhoto();
        });
        
        // Image control event listeners
        // No image control event listeners needed
        // Keyboard navigation in photo viewer
        document.addEventListener('keydown', function (e) {
            if (photoViewerOverlay.style.display === 'flex') {
                if (e.key === 'Escape') {
                    closePhotoViewer();
                } else if (e.key === 'ArrowRight') {
                    showNextPhoto();
                } else if (e.key === 'ArrowLeft') {
                    showPreviousPhoto();
                }
            }
        });
        // Load data when page is loaded
        window.addEventListener('load', function () {
            debugLog('Page loaded, fetching photo data...');
            loadPhotoData();

            // No need for debug cluster handlers anymore - our improved handler is added
        // when markers are created
            
            // We've removed the document-level click fallback handler since it was causing
            // the wrong photos to be shown. The proper handler is now added in finishMarkerLoading.
        });
        // Simple photo navigation functions

        // We've removed the debug cluster function as it was causing conflicts
        // The proper handler is now added in finishMarkerLoading

        function createLibraryFilters(libraries) {
    const container = document.getElementById('libraryFilterContainer');
    const selectAllCheckbox = document.getElementById('selectAllLibraries');

    // Clear any existing filters
    container.innerHTML = '';

    if (!libraries || libraries.length === 0) {
        container.innerHTML = '<p>No libraries available</p>';
        return;
    }

    // Add individual library checkboxes
    libraries.forEach(library => {
        const libraryPhotos = photoData.photos.filter(photo => photo.library_id === library.id);
        const geotaggedCount = libraryPhotos.filter(photo =>
            photo.latitude != null && photo.longitude != null).length;

        const div = document.createElement('div');
        div.className = 'library-checkbox checkbox-container';
        div.style.marginLeft = '0';
        div.style.paddingLeft = '0';

        // Create checkbox input
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `library-${library.id}`;
        checkbox.checked = true;
        checkbox.dataset.libraryId = library.id;
        checkbox.className = 'library-filter';
        checkbox.style.marginLeft = '0';
        checkbox.style.marginRight = '5px';

        // Create label
        const label = document.createElement('label');
        label.htmlFor = `library-${library.id}`;
        label.className = 'library-label';

        // Add update time data if available
        // First check if the library object has the last_updated field directly from API
        if (library.last_updated) {
            label.dataset.updateTime = library.last_updated;
        }
        // Fall back to the window.libraryUpdateTimes from legacy API
        else if (window.libraryUpdateTimes && window.libraryUpdateTimes[library.name]) {
            label.dataset.updateTime = window.libraryUpdateTimes[library.name];
        }

        // Create text nodes and count span
        const nameText = document.createTextNode(library.name + ' ');
        const countSpan = document.createElement('span');
        countSpan.className = 'library-count';
        countSpan.textContent = `(${geotaggedCount} photos)`;

        // Build the label structure
        label.appendChild(nameText);
        label.appendChild(countSpan);

        // Build the checkbox div
        div.appendChild(checkbox);
        div.appendChild(label);

        // Add to container
        container.appendChild(div);

        // Add event listener
        checkbox.addEventListener('change', updateLibrarySelection);
    });

    // Add "Select All" functionality
    selectAllCheckbox.addEventListener('change', function() {
        const isChecked = selectAllCheckbox.checked;
        document.querySelectorAll('.library-filter').forEach(cb => {
            cb.checked = isChecked;
        });
        updateLibrarySelection();
    });

    // Initial update
    updateLibrarySelection();

    // Apply tooltips to library labels
    updateLibraryLabelsWithTooltips();
}

        function updateLibrarySelection() {
            // Update which libraries are selected
            const selectedLibraries = [];
            document.querySelectorAll('.library-filter:checked').forEach(checkbox => {
                selectedLibraries.push(parseInt(checkbox.dataset.libraryId));
            });

            photoData.activeLibraries = selectedLibraries;

            // Update the "Select All" checkbox state
            const allLibrariesCheckbox = document.getElementById('selectAllLibraries');
            const allLibraries = document.querySelectorAll('.library-filter');
            const selectedCount = document.querySelectorAll('.library-filter:checked').length;

            if (selectedCount === 0) {
                allLibrariesCheckbox.checked = false;
                allLibrariesCheckbox.indeterminate = false;
            } else if (selectedCount === allLibraries.length) {
                allLibrariesCheckbox.checked = true;
                allLibrariesCheckbox.indeterminate = false;
            } else {
                allLibrariesCheckbox.indeterminate = true;
            }

            // Show the main loading indicator when updating library selection
            // because this is a substantial operation that recreates markers
            const loadingElement = document.getElementById('loading');
            const loadingMessage = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('progressBar');
            
            if (loadingElement && loadingMessage && progressBar) {
                loadingElement.style.display = 'flex';
                loadingMessage.textContent = 'Updating library selection...';
                progressBar.style.width = '30%';
                
                debugLog(`Library selection changed, updating map with progress bar...`);
                
                // Use setTimeout to allow the UI to update before heavy processing
                setTimeout(() => {
                    // Update progress to show we're working on the heatmap
                    progressBar.style.width = '50%';
                    loadingMessage.textContent = 'Updating heatmap...';
                    
                    setTimeout(() => {
                        // Force recreation of markers for library changes
                        if (markerGroup) {
                            debugLog('Clearing existing markers for library selection change');
                            map.removeLayer(markerGroup);
                            markerGroup = null; // Force recreation of markers
                        }
                        
                        // For library selection we need to update all visualizations
                        // because it changes the underlying dataset
                        // Set a flag to indicate we're processing library selection
                        window._processingLibrarySelection = true;
                        filterAndUpdateMap();
                        
                        // We don't complete the progress here because filterAndUpdateMap 
                        // will trigger updateMarkers which will handle progress completion
                        // The progress completion is now managed by the marker loading process
                    }, 50);
                }, 50);
            } else {
                // Fallback if progress elements aren't found
                debugLog(`Library selection changed, updating map...`);
                filterAndUpdateMap();
            }
        }

        function filterAndUpdateMap() {
            if (!photoData || !photoData.photos) return;

            const loadingElement = document.getElementById('loading');
            const progressBar = document.getElementById('progressBar');
            const loadingMessage = document.getElementById('loadingMessage');
            
            // Check if progress is already showing (called from updateLibrarySelection)
            const progressAlreadyShowing = loadingElement && loadingElement.style.display === 'flex';
            
            // Show progress if not already showing
            if (!progressAlreadyShowing && loadingElement) {
                loadingElement.style.display = 'flex';
                if (progressBar) progressBar.style.width = '20%';
                if (loadingMessage) loadingMessage.textContent = 'Filtering photos...';
            }

            // Get all photos from active libraries
            let filteredPhotos = photoData.photos.filter(photo =>
                photoData.activeLibraries.includes(photo.library_id) &&
                photo.latitude != null && photo.longitude != null
            );

            debugLog(`Filtered to ${filteredPhotos.length} photos from ${photoData.activeLibraries.length} libraries`);

            // Update photo count display
            photoCountElement.textContent = `${filteredPhotos.length} photos with location`;

            // Update progress - heatmap step
            if (!progressAlreadyShowing && progressBar) {
                progressBar.style.width = '50%';
                if (loadingMessage) loadingMessage.textContent = 'Updating heatmap...';
            }

            // Update heatmap
            updateHeatmap(filteredPhotos);
            
            // Update progress - marker step
            if (!progressAlreadyShowing && progressBar) {
                progressBar.style.width = '70%';
                if (loadingMessage) loadingMessage.textContent = 'Updating markers...';
            }
            
            // Handle markers differently depending on context
            if (showMarkersCheckbox.checked) {
                debugLog('Updating markers for complete refresh');
                
                // When updating from library selection, we need to recreate markers 
                // to reflect the new filtered dataset
                const fromLibrarySelection = 
                    document.getElementById('loadingMessage') && 
                    document.getElementById('loadingMessage').textContent && 
                    document.getElementById('loadingMessage').textContent.includes('library');
                
                if (fromLibrarySelection || !markerGroup) {
                    // If coming from library selection or no marker group exists yet,
                    // create new markers with filtered data
                    debugLog('Recreating markers for library selection change');
                    
                    // First remove existing markers if any
                    if (markerGroup && map.hasLayer(markerGroup)) {
                        map.removeLayer(markerGroup);
                        markerGroup = null; // Force recreation
                    }
                    
                    // Then create new markers with the filtered data
                    updateMarkers(filteredPhotos);
                } else if (markerGroup) {
                    // For other updates, just add the existing marker group if needed
                    if (!map.hasLayer(markerGroup)) {
                        debugLog('Showing existing marker group');
                        map.addLayer(markerGroup);
                    }
                }
            } else if (markerGroup && map.hasLayer(markerGroup)) {
                // Just hide markers if they're toggled off
                debugLog('Removing markers during complete refresh');
                map.removeLayer(markerGroup);
            }
            
            // Only complete progress if we're not going to load markers
            // (which has its own progress handling)
            if (!showMarkersCheckbox.checked && !progressAlreadyShowing && loadingElement) {
                if (progressBar) progressBar.style.width = '100%';
                if (loadingMessage) loadingMessage.textContent = 'Complete!';
                
                // Hide after a short delay
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, 500);
            }
            // Otherwise, let the marker loading handle the progress completion
        }

        // Fullscreen functionality removed
        
        // Marker updating functionality is defined elsewhere
        
    </script>

    <script>
        // Global variable to store library update times
        window.libraryUpdateTimes = {};

        // Function to fetch library update times
        function fetchLibraryUpdateTimes() {
            fetch('/library_updates')
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    throw new Error('Network response was not ok');
                })
                .then(data => {
                    if (data && data.updates) {
                        window.libraryUpdateTimes = data.updates;
                        console.log('Library update times loaded:', window.libraryUpdateTimes);

                        // Update any existing library labels with tooltips
                        updateLibraryLabelsWithTooltips();
                    }
                })
                .catch(error => {
                    console.error('Error loading library update times:', error);
                });
        }

        // Function to update library labels with tooltips
        function updateLibraryLabelsWithTooltips() {
            // Find all library labels and update them with tooltip data
            document.querySelectorAll('.library-label').forEach(label => {
                const libraryName = label.textContent.trim().split(' ')[0]; // Get just the library name
                if (window.libraryUpdateTimes[libraryName]) {
                    label.setAttribute('data-update-time', window.libraryUpdateTimes[libraryName]);                    
                }
            });
        }

        // Call the function when the document is loaded and then periodically
        document.addEventListener('DOMContentLoaded', () => {
            fetchLibraryUpdateTimes();
            setInterval(fetchLibraryUpdateTimes, 60000); // Update every minute
        });    </script>
    <!-- Library updates are now displayed as tooltips when hovering over library names -->
</body>

</html>